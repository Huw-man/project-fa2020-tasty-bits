import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.7.0
 * Query Engine version: eaade828a21d8ee3f4940f0af7da3ae0922db4df
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findOne'
  | 'findMany'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$queryRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): UserDelegate;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): CategoryDelegate;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): QuestionDelegate;

  /**
   * `prisma.questionVote`: Exposes CRUD operations for the **QuestionVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionVotes
    * const questionVotes = await prisma.questionVote.findMany()
    * ```
    */
  get questionVote(): QuestionVoteDelegate;

  /**
   * `prisma.questionClick`: Exposes CRUD operations for the **QuestionClick** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionClicks
    * const questionClicks = await prisma.questionClick.findMany()
    * ```
    */
  get questionClick(): QuestionClickDelegate;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): AnswerDelegate;

  /**
   * `prisma.answerVote`: Exposes CRUD operations for the **AnswerVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnswerVotes
    * const answerVotes = await prisma.answerVote.findMany()
    * ```
    */
  get answerVote(): AnswerVoteDelegate;

  /**
   * `prisma.chatroom`: Exposes CRUD operations for the **Chatroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatrooms
    * const chatrooms = await prisma.chatroom.findMany()
    * ```
    */
  get chatroom(): ChatroomDelegate;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): MessageDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const UserDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  biography: 'biography',
  class: 'class',
  major: 'major',
  profileVisibility: 'profileVisibility',
  linkedin: 'linkedin',
  facebook: 'facebook',
  twitter: 'twitter',
  instagram: 'instagram',
  snapchat: 'snapchat',
  tiktok: 'tiktok',
  openToHelp: 'openToHelp',
  studentType: 'studentType'
};

export declare type UserDistinctFieldEnum = (typeof UserDistinctFieldEnum)[keyof typeof UserDistinctFieldEnum]


export declare const CategoryDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name'
};

export declare type CategoryDistinctFieldEnum = (typeof CategoryDistinctFieldEnum)[keyof typeof CategoryDistinctFieldEnum]


export declare const QuestionDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  title: 'title',
  description: 'description',
  deletedAt: 'deletedAt',
  userId: 'userId'
};

export declare type QuestionDistinctFieldEnum = (typeof QuestionDistinctFieldEnum)[keyof typeof QuestionDistinctFieldEnum]


export declare const QuestionVoteDistinctFieldEnum: {
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  upDown: 'upDown',
  questionId: 'questionId',
  userId: 'userId'
};

export declare type QuestionVoteDistinctFieldEnum = (typeof QuestionVoteDistinctFieldEnum)[keyof typeof QuestionVoteDistinctFieldEnum]


export declare const QuestionClickDistinctFieldEnum: {
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  questionId: 'questionId',
  userId: 'userId'
};

export declare type QuestionClickDistinctFieldEnum = (typeof QuestionClickDistinctFieldEnum)[keyof typeof QuestionClickDistinctFieldEnum]


export declare const AnswerDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  content: 'content',
  questionId: 'questionId',
  deletedAt: 'deletedAt',
  userId: 'userId'
};

export declare type AnswerDistinctFieldEnum = (typeof AnswerDistinctFieldEnum)[keyof typeof AnswerDistinctFieldEnum]


export declare const AnswerVoteDistinctFieldEnum: {
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  upDown: 'upDown',
  answerId: 'answerId',
  userId: 'userId'
};

export declare type AnswerVoteDistinctFieldEnum = (typeof AnswerVoteDistinctFieldEnum)[keyof typeof AnswerVoteDistinctFieldEnum]


export declare const ChatroomDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};

export declare type ChatroomDistinctFieldEnum = (typeof ChatroomDistinctFieldEnum)[keyof typeof ChatroomDistinctFieldEnum]


export declare const MessageDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  content: 'content',
  userId: 'userId',
  chatroomId: 'chatroomId'
};

export declare type MessageDistinctFieldEnum = (typeof MessageDistinctFieldEnum)[keyof typeof MessageDistinctFieldEnum]


export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export declare const ProfileVisibility: {
  NONE: 'NONE',
  FULL: 'FULL'
};

export declare type ProfileVisibility = (typeof ProfileVisibility)[keyof typeof ProfileVisibility]


export declare const StudentType: {
  GENERAL: 'GENERAL',
  INTERNATIONAL: 'INTERNATIONAL',
  FIRSTGEN: 'FIRSTGEN',
  TRANSFER: 'TRANSFER'
};

export declare type StudentType = (typeof StudentType)[keyof typeof StudentType]



/**
 * Model User
 */

export type User = {
  id: string
  createdAt: Date
  updatedAt: Date
  name: string | null
  biography: string | null
  class: string | null
  major: string | null
  profileVisibility: ProfileVisibility
  linkedin: string | null
  facebook: string | null
  twitter: string | null
  instagram: string | null
  snapchat: string | null
  tiktok: string | null
  openToHelp: boolean | null
  studentType: StudentType
}


export type AggregateUser = {
  count: number
}



export type AggregateUserArgs = {
  where?: UserWhereInput
  orderBy?: Enumerable<UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
  count?: true
}

export type GetUserAggregateType<T extends AggregateUserArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type UserSelect = {
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  name?: boolean
  biography?: boolean
  class?: boolean
  major?: boolean
  profileVisibility?: boolean
  linkedin?: boolean
  facebook?: boolean
  twitter?: boolean
  instagram?: boolean
  snapchat?: boolean
  tiktok?: boolean
  openToHelp?: boolean
  studentType?: boolean
  chatrooms?: boolean | FindManyChatroomArgs
  questions?: boolean | FindManyQuestionArgs
  questionVotes?: boolean | FindManyQuestionVoteArgs
  questionClicks?: boolean | FindManyQuestionClickArgs
  answerVotes?: boolean | FindManyAnswerVoteArgs
  answers?: boolean | FindManyAnswerArgs
  messages?: boolean | FindManyMessageArgs
}

export type UserInclude = {
  chatrooms?: boolean | FindManyChatroomArgs
  questions?: boolean | FindManyQuestionArgs
  questionVotes?: boolean | FindManyQuestionVoteArgs
  questionClicks?: boolean | FindManyQuestionClickArgs
  answerVotes?: boolean | FindManyAnswerVoteArgs
  answers?: boolean | FindManyAnswerArgs
  messages?: boolean | FindManyMessageArgs
}

export type UserGetPayload<
  S extends boolean | null | undefined | UserArgs,
  U = keyof S
> = S extends true
  ? User
  : S extends undefined
  ? never
  : S extends UserArgs | FindManyUserArgs
  ? 'include' extends U
    ? User  & {
      [P in TrueKeys<S['include']>]:
      P extends 'chatrooms'
      ? Array<ChatroomGetPayload<S['include'][P]>> :
      P extends 'questions'
      ? Array<QuestionGetPayload<S['include'][P]>> :
      P extends 'questionVotes'
      ? Array<QuestionVoteGetPayload<S['include'][P]>> :
      P extends 'questionClicks'
      ? Array<QuestionClickGetPayload<S['include'][P]>> :
      P extends 'answerVotes'
      ? Array<AnswerVoteGetPayload<S['include'][P]>> :
      P extends 'answers'
      ? Array<AnswerGetPayload<S['include'][P]>> :
      P extends 'messages'
      ? Array<MessageGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof User ? User[P]
: 
      P extends 'chatrooms'
      ? Array<ChatroomGetPayload<S['select'][P]>> :
      P extends 'questions'
      ? Array<QuestionGetPayload<S['select'][P]>> :
      P extends 'questionVotes'
      ? Array<QuestionVoteGetPayload<S['select'][P]>> :
      P extends 'questionClicks'
      ? Array<QuestionClickGetPayload<S['select'][P]>> :
      P extends 'answerVotes'
      ? Array<AnswerVoteGetPayload<S['select'][P]>> :
      P extends 'answers'
      ? Array<AnswerGetPayload<S['select'][P]>> :
      P extends 'messages'
      ? Array<MessageGetPayload<S['select'][P]>> : never
    }
  : User
: User


export interface UserDelegate {
  /**
   * Find zero or one User.
   * @param {FindOneUserArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneUserArgs>(
    args: Subset<T, FindOneUserArgs>
  ): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>
  /**
   * Find zero or more Users.
   * @param {FindManyUserArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Users
   * const users = await prisma.user.findMany()
   * 
   * // Get first 10 Users
   * const users = await prisma.user.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyUserArgs>(
    args?: Subset<T, FindManyUserArgs>
  ): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>
  /**
   * Create a User.
   * @param {UserCreateArgs} args - Arguments to create a User.
   * @example
   * // Create one User
   * const User = await prisma.user.create({
   *   data: {
   *     // ... data to create a User
   *   }
   * })
   * 
  **/
  create<T extends UserCreateArgs>(
    args: Subset<T, UserCreateArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Delete a User.
   * @param {UserDeleteArgs} args - Arguments to delete one User.
   * @example
   * // Delete one User
   * const User = await prisma.user.delete({
   *   where: {
   *     // ... filter to delete one User
   *   }
   * })
   * 
  **/
  delete<T extends UserDeleteArgs>(
    args: Subset<T, UserDeleteArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Update one User.
   * @param {UserUpdateArgs} args - Arguments to update one User.
   * @example
   * // Update one User
   * const user = await prisma.user.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends UserUpdateArgs>(
    args: Subset<T, UserUpdateArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Delete zero or more Users.
   * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
   * @example
   * // Delete a few Users
   * const { count } = await prisma.user.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends UserDeleteManyArgs>(
    args: Subset<T, UserDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Users.
   * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Users
   * const user = await prisma.user.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends UserUpdateManyArgs>(
    args: Subset<T, UserUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one User.
   * @param {UserUpsertArgs} args - Arguments to update or create a User.
   * @example
   * // Update or create a User
   * const user = await prisma.user.upsert({
   *   create: {
   *     // ... data to create a User
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the User we want to update
   *   }
   * })
  **/
  upsert<T extends UserUpsertArgs>(
    args: Subset<T, UserUpsertArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyUserArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateUserArgs>(args: Subset<T, AggregateUserArgs>): Promise<GetUserAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for User.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__UserClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  chatrooms<T extends FindManyChatroomArgs = {}>(args?: Subset<T, FindManyChatroomArgs>): CheckSelect<T, Promise<Array<Chatroom>>, Promise<Array<ChatroomGetPayload<T>>>>;

  questions<T extends FindManyQuestionArgs = {}>(args?: Subset<T, FindManyQuestionArgs>): CheckSelect<T, Promise<Array<Question>>, Promise<Array<QuestionGetPayload<T>>>>;

  questionVotes<T extends FindManyQuestionVoteArgs = {}>(args?: Subset<T, FindManyQuestionVoteArgs>): CheckSelect<T, Promise<Array<QuestionVote>>, Promise<Array<QuestionVoteGetPayload<T>>>>;

  questionClicks<T extends FindManyQuestionClickArgs = {}>(args?: Subset<T, FindManyQuestionClickArgs>): CheckSelect<T, Promise<Array<QuestionClick>>, Promise<Array<QuestionClickGetPayload<T>>>>;

  answerVotes<T extends FindManyAnswerVoteArgs = {}>(args?: Subset<T, FindManyAnswerVoteArgs>): CheckSelect<T, Promise<Array<AnswerVote>>, Promise<Array<AnswerVoteGetPayload<T>>>>;

  answers<T extends FindManyAnswerArgs = {}>(args?: Subset<T, FindManyAnswerArgs>): CheckSelect<T, Promise<Array<Answer>>, Promise<Array<AnswerGetPayload<T>>>>;

  messages<T extends FindManyMessageArgs = {}>(args?: Subset<T, FindManyMessageArgs>): CheckSelect<T, Promise<Array<Message>>, Promise<Array<MessageGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * User findOne
 */
export type FindOneUserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter, which User to fetch.
  **/
  where: UserWhereUniqueInput
}


/**
 * User findMany
 */
export type FindManyUserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter, which Users to fetch.
  **/
  where?: UserWhereInput
  /**
   * Determine the order of the Users to fetch.
  **/
  orderBy?: Enumerable<UserOrderByInput>
  /**
   * Sets the position for listing Users.
  **/
  cursor?: UserWhereUniqueInput
  /**
   * The number of Users to fetch. If negative number, it will take Users before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Users.
  **/
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}


/**
 * User create
 */
export type UserCreateArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The data needed to create a User.
  **/
  data: UserCreateInput
}


/**
 * User update
 */
export type UserUpdateArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The data needed to update a User.
  **/
  data: UserUpdateInput
  /**
   * Choose, which User to update.
  **/
  where: UserWhereUniqueInput
}


/**
 * User updateMany
 */
export type UserUpdateManyArgs = {
  data: UserUpdateManyMutationInput
  where?: UserWhereInput
}


/**
 * User upsert
 */
export type UserUpsertArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The filter to search for the User to update in case it exists.
  **/
  where: UserWhereUniqueInput
  /**
   * In case the User found by the `where` argument doesn't exist, create a new User with this data.
  **/
  create: UserCreateInput
  /**
   * In case the User was found with the provided `where` argument, update it with this data.
  **/
  update: UserUpdateInput
}


/**
 * User delete
 */
export type UserDeleteArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter which User to delete.
  **/
  where: UserWhereUniqueInput
}


/**
 * User deleteMany
 */
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}


/**
 * User without action
 */
export type UserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
}



/**
 * Model Category
 */

export type Category = {
  id: string
  createdAt: Date
  updatedAt: Date
  name: string
}


export type AggregateCategory = {
  count: number
}



export type AggregateCategoryArgs = {
  where?: CategoryWhereInput
  orderBy?: Enumerable<CategoryOrderByInput>
  cursor?: CategoryWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<CategoryDistinctFieldEnum>
  count?: true
}

export type GetCategoryAggregateType<T extends AggregateCategoryArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type CategorySelect = {
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  name?: boolean
  questions?: boolean | FindManyQuestionArgs
}

export type CategoryInclude = {
  questions?: boolean | FindManyQuestionArgs
}

export type CategoryGetPayload<
  S extends boolean | null | undefined | CategoryArgs,
  U = keyof S
> = S extends true
  ? Category
  : S extends undefined
  ? never
  : S extends CategoryArgs | FindManyCategoryArgs
  ? 'include' extends U
    ? Category  & {
      [P in TrueKeys<S['include']>]:
      P extends 'questions'
      ? Array<QuestionGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Category ? Category[P]
: 
      P extends 'questions'
      ? Array<QuestionGetPayload<S['select'][P]>> : never
    }
  : Category
: Category


export interface CategoryDelegate {
  /**
   * Find zero or one Category.
   * @param {FindOneCategoryArgs} args - Arguments to find a Category
   * @example
   * // Get one Category
   * const category = await prisma.category.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneCategoryArgs>(
    args: Subset<T, FindOneCategoryArgs>
  ): CheckSelect<T, Prisma__CategoryClient<Category | null>, Prisma__CategoryClient<CategoryGetPayload<T> | null>>
  /**
   * Find zero or more Categories.
   * @param {FindManyCategoryArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Categories
   * const categories = await prisma.category.findMany()
   * 
   * // Get first 10 Categories
   * const categories = await prisma.category.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyCategoryArgs>(
    args?: Subset<T, FindManyCategoryArgs>
  ): CheckSelect<T, Promise<Array<Category>>, Promise<Array<CategoryGetPayload<T>>>>
  /**
   * Create a Category.
   * @param {CategoryCreateArgs} args - Arguments to create a Category.
   * @example
   * // Create one Category
   * const Category = await prisma.category.create({
   *   data: {
   *     // ... data to create a Category
   *   }
   * })
   * 
  **/
  create<T extends CategoryCreateArgs>(
    args: Subset<T, CategoryCreateArgs>
  ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>
  /**
   * Delete a Category.
   * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
   * @example
   * // Delete one Category
   * const Category = await prisma.category.delete({
   *   where: {
   *     // ... filter to delete one Category
   *   }
   * })
   * 
  **/
  delete<T extends CategoryDeleteArgs>(
    args: Subset<T, CategoryDeleteArgs>
  ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>
  /**
   * Update one Category.
   * @param {CategoryUpdateArgs} args - Arguments to update one Category.
   * @example
   * // Update one Category
   * const category = await prisma.category.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends CategoryUpdateArgs>(
    args: Subset<T, CategoryUpdateArgs>
  ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>
  /**
   * Delete zero or more Categories.
   * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
   * @example
   * // Delete a few Categories
   * const { count } = await prisma.category.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends CategoryDeleteManyArgs>(
    args: Subset<T, CategoryDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Categories.
   * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Categories
   * const category = await prisma.category.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends CategoryUpdateManyArgs>(
    args: Subset<T, CategoryUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Category.
   * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
   * @example
   * // Update or create a Category
   * const category = await prisma.category.upsert({
   *   create: {
   *     // ... data to create a Category
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Category we want to update
   *   }
   * })
  **/
  upsert<T extends CategoryUpsertArgs>(
    args: Subset<T, CategoryUpsertArgs>
  ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyCategoryArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateCategoryArgs>(args: Subset<T, AggregateCategoryArgs>): Promise<GetCategoryAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Category.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__CategoryClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  questions<T extends FindManyQuestionArgs = {}>(args?: Subset<T, FindManyQuestionArgs>): CheckSelect<T, Promise<Array<Question>>, Promise<Array<QuestionGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Category findOne
 */
export type FindOneCategoryArgs = {
  /**
   * Select specific fields to fetch from the Category
  **/
  select?: CategorySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CategoryInclude | null
  /**
   * Filter, which Category to fetch.
  **/
  where: CategoryWhereUniqueInput
}


/**
 * Category findMany
 */
export type FindManyCategoryArgs = {
  /**
   * Select specific fields to fetch from the Category
  **/
  select?: CategorySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CategoryInclude | null
  /**
   * Filter, which Categories to fetch.
  **/
  where?: CategoryWhereInput
  /**
   * Determine the order of the Categories to fetch.
  **/
  orderBy?: Enumerable<CategoryOrderByInput>
  /**
   * Sets the position for listing Categories.
  **/
  cursor?: CategoryWhereUniqueInput
  /**
   * The number of Categories to fetch. If negative number, it will take Categories before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Categories.
  **/
  skip?: number
  distinct?: Enumerable<CategoryDistinctFieldEnum>
}


/**
 * Category create
 */
export type CategoryCreateArgs = {
  /**
   * Select specific fields to fetch from the Category
  **/
  select?: CategorySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CategoryInclude | null
  /**
   * The data needed to create a Category.
  **/
  data: CategoryCreateInput
}


/**
 * Category update
 */
export type CategoryUpdateArgs = {
  /**
   * Select specific fields to fetch from the Category
  **/
  select?: CategorySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CategoryInclude | null
  /**
   * The data needed to update a Category.
  **/
  data: CategoryUpdateInput
  /**
   * Choose, which Category to update.
  **/
  where: CategoryWhereUniqueInput
}


/**
 * Category updateMany
 */
export type CategoryUpdateManyArgs = {
  data: CategoryUpdateManyMutationInput
  where?: CategoryWhereInput
}


/**
 * Category upsert
 */
export type CategoryUpsertArgs = {
  /**
   * Select specific fields to fetch from the Category
  **/
  select?: CategorySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CategoryInclude | null
  /**
   * The filter to search for the Category to update in case it exists.
  **/
  where: CategoryWhereUniqueInput
  /**
   * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
  **/
  create: CategoryCreateInput
  /**
   * In case the Category was found with the provided `where` argument, update it with this data.
  **/
  update: CategoryUpdateInput
}


/**
 * Category delete
 */
export type CategoryDeleteArgs = {
  /**
   * Select specific fields to fetch from the Category
  **/
  select?: CategorySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CategoryInclude | null
  /**
   * Filter which Category to delete.
  **/
  where: CategoryWhereUniqueInput
}


/**
 * Category deleteMany
 */
export type CategoryDeleteManyArgs = {
  where?: CategoryWhereInput
}


/**
 * Category without action
 */
export type CategoryArgs = {
  /**
   * Select specific fields to fetch from the Category
  **/
  select?: CategorySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CategoryInclude | null
}



/**
 * Model Question
 */

export type Question = {
  id: string
  createdAt: Date
  updatedAt: Date
  title: string
  description: string | null
  deletedAt: Date | null
  userId: string
}


export type AggregateQuestion = {
  count: number
}



export type AggregateQuestionArgs = {
  where?: QuestionWhereInput
  orderBy?: Enumerable<QuestionOrderByInput>
  cursor?: QuestionWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<QuestionDistinctFieldEnum>
  count?: true
}

export type GetQuestionAggregateType<T extends AggregateQuestionArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type QuestionSelect = {
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  title?: boolean
  description?: boolean
  votes?: boolean | FindManyQuestionVoteArgs
  clicks?: boolean | FindManyQuestionClickArgs
  answers?: boolean | FindManyAnswerArgs
  deletedAt?: boolean
  user?: boolean | UserArgs
  userId?: boolean
  categories?: boolean | FindManyCategoryArgs
}

export type QuestionInclude = {
  votes?: boolean | FindManyQuestionVoteArgs
  clicks?: boolean | FindManyQuestionClickArgs
  answers?: boolean | FindManyAnswerArgs
  user?: boolean | UserArgs
  categories?: boolean | FindManyCategoryArgs
}

export type QuestionGetPayload<
  S extends boolean | null | undefined | QuestionArgs,
  U = keyof S
> = S extends true
  ? Question
  : S extends undefined
  ? never
  : S extends QuestionArgs | FindManyQuestionArgs
  ? 'include' extends U
    ? Question  & {
      [P in TrueKeys<S['include']>]:
      P extends 'votes'
      ? Array<QuestionVoteGetPayload<S['include'][P]>> :
      P extends 'clicks'
      ? Array<QuestionClickGetPayload<S['include'][P]>> :
      P extends 'answers'
      ? Array<AnswerGetPayload<S['include'][P]>> :
      P extends 'user'
      ? UserGetPayload<S['include'][P]> :
      P extends 'categories'
      ? Array<CategoryGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Question ? Question[P]
: 
      P extends 'votes'
      ? Array<QuestionVoteGetPayload<S['select'][P]>> :
      P extends 'clicks'
      ? Array<QuestionClickGetPayload<S['select'][P]>> :
      P extends 'answers'
      ? Array<AnswerGetPayload<S['select'][P]>> :
      P extends 'user'
      ? UserGetPayload<S['select'][P]> :
      P extends 'categories'
      ? Array<CategoryGetPayload<S['select'][P]>> : never
    }
  : Question
: Question


export interface QuestionDelegate {
  /**
   * Find zero or one Question.
   * @param {FindOneQuestionArgs} args - Arguments to find a Question
   * @example
   * // Get one Question
   * const question = await prisma.question.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneQuestionArgs>(
    args: Subset<T, FindOneQuestionArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question | null>, Prisma__QuestionClient<QuestionGetPayload<T> | null>>
  /**
   * Find zero or more Questions.
   * @param {FindManyQuestionArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Questions
   * const questions = await prisma.question.findMany()
   * 
   * // Get first 10 Questions
   * const questions = await prisma.question.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyQuestionArgs>(
    args?: Subset<T, FindManyQuestionArgs>
  ): CheckSelect<T, Promise<Array<Question>>, Promise<Array<QuestionGetPayload<T>>>>
  /**
   * Create a Question.
   * @param {QuestionCreateArgs} args - Arguments to create a Question.
   * @example
   * // Create one Question
   * const Question = await prisma.question.create({
   *   data: {
   *     // ... data to create a Question
   *   }
   * })
   * 
  **/
  create<T extends QuestionCreateArgs>(
    args: Subset<T, QuestionCreateArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>
  /**
   * Delete a Question.
   * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
   * @example
   * // Delete one Question
   * const Question = await prisma.question.delete({
   *   where: {
   *     // ... filter to delete one Question
   *   }
   * })
   * 
  **/
  delete<T extends QuestionDeleteArgs>(
    args: Subset<T, QuestionDeleteArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>
  /**
   * Update one Question.
   * @param {QuestionUpdateArgs} args - Arguments to update one Question.
   * @example
   * // Update one Question
   * const question = await prisma.question.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends QuestionUpdateArgs>(
    args: Subset<T, QuestionUpdateArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>
  /**
   * Delete zero or more Questions.
   * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
   * @example
   * // Delete a few Questions
   * const { count } = await prisma.question.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends QuestionDeleteManyArgs>(
    args: Subset<T, QuestionDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Questions.
   * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Questions
   * const question = await prisma.question.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends QuestionUpdateManyArgs>(
    args: Subset<T, QuestionUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Question.
   * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
   * @example
   * // Update or create a Question
   * const question = await prisma.question.upsert({
   *   create: {
   *     // ... data to create a Question
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Question we want to update
   *   }
   * })
  **/
  upsert<T extends QuestionUpsertArgs>(
    args: Subset<T, QuestionUpsertArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyQuestionArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateQuestionArgs>(args: Subset<T, AggregateQuestionArgs>): Promise<GetQuestionAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Question.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__QuestionClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  votes<T extends FindManyQuestionVoteArgs = {}>(args?: Subset<T, FindManyQuestionVoteArgs>): CheckSelect<T, Promise<Array<QuestionVote>>, Promise<Array<QuestionVoteGetPayload<T>>>>;

  clicks<T extends FindManyQuestionClickArgs = {}>(args?: Subset<T, FindManyQuestionClickArgs>): CheckSelect<T, Promise<Array<QuestionClick>>, Promise<Array<QuestionClickGetPayload<T>>>>;

  answers<T extends FindManyAnswerArgs = {}>(args?: Subset<T, FindManyAnswerArgs>): CheckSelect<T, Promise<Array<Answer>>, Promise<Array<AnswerGetPayload<T>>>>;

  user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  categories<T extends FindManyCategoryArgs = {}>(args?: Subset<T, FindManyCategoryArgs>): CheckSelect<T, Promise<Array<Category>>, Promise<Array<CategoryGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Question findOne
 */
export type FindOneQuestionArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * Filter, which Question to fetch.
  **/
  where: QuestionWhereUniqueInput
}


/**
 * Question findMany
 */
export type FindManyQuestionArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * Filter, which Questions to fetch.
  **/
  where?: QuestionWhereInput
  /**
   * Determine the order of the Questions to fetch.
  **/
  orderBy?: Enumerable<QuestionOrderByInput>
  /**
   * Sets the position for listing Questions.
  **/
  cursor?: QuestionWhereUniqueInput
  /**
   * The number of Questions to fetch. If negative number, it will take Questions before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Questions.
  **/
  skip?: number
  distinct?: Enumerable<QuestionDistinctFieldEnum>
}


/**
 * Question create
 */
export type QuestionCreateArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * The data needed to create a Question.
  **/
  data: QuestionCreateInput
}


/**
 * Question update
 */
export type QuestionUpdateArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * The data needed to update a Question.
  **/
  data: QuestionUpdateInput
  /**
   * Choose, which Question to update.
  **/
  where: QuestionWhereUniqueInput
}


/**
 * Question updateMany
 */
export type QuestionUpdateManyArgs = {
  data: QuestionUpdateManyMutationInput
  where?: QuestionWhereInput
}


/**
 * Question upsert
 */
export type QuestionUpsertArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * The filter to search for the Question to update in case it exists.
  **/
  where: QuestionWhereUniqueInput
  /**
   * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
  **/
  create: QuestionCreateInput
  /**
   * In case the Question was found with the provided `where` argument, update it with this data.
  **/
  update: QuestionUpdateInput
}


/**
 * Question delete
 */
export type QuestionDeleteArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * Filter which Question to delete.
  **/
  where: QuestionWhereUniqueInput
}


/**
 * Question deleteMany
 */
export type QuestionDeleteManyArgs = {
  where?: QuestionWhereInput
}


/**
 * Question without action
 */
export type QuestionArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
}



/**
 * Model QuestionVote
 */

export type QuestionVote = {
  createdAt: Date
  updatedAt: Date
  upDown: boolean
  questionId: string
  userId: string
}


export type AggregateQuestionVote = {
  count: number
}



export type AggregateQuestionVoteArgs = {
  where?: QuestionVoteWhereInput
  orderBy?: Enumerable<QuestionVoteOrderByInput>
  cursor?: QuestionVoteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<QuestionVoteDistinctFieldEnum>
  count?: true
}

export type GetQuestionVoteAggregateType<T extends AggregateQuestionVoteArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type QuestionVoteSelect = {
  createdAt?: boolean
  updatedAt?: boolean
  upDown?: boolean
  question?: boolean | QuestionArgs
  questionId?: boolean
  user?: boolean | UserArgs
  userId?: boolean
}

export type QuestionVoteInclude = {
  question?: boolean | QuestionArgs
  user?: boolean | UserArgs
}

export type QuestionVoteGetPayload<
  S extends boolean | null | undefined | QuestionVoteArgs,
  U = keyof S
> = S extends true
  ? QuestionVote
  : S extends undefined
  ? never
  : S extends QuestionVoteArgs | FindManyQuestionVoteArgs
  ? 'include' extends U
    ? QuestionVote  & {
      [P in TrueKeys<S['include']>]:
      P extends 'question'
      ? QuestionGetPayload<S['include'][P]> :
      P extends 'user'
      ? UserGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof QuestionVote ? QuestionVote[P]
: 
      P extends 'question'
      ? QuestionGetPayload<S['select'][P]> :
      P extends 'user'
      ? UserGetPayload<S['select'][P]> : never
    }
  : QuestionVote
: QuestionVote


export interface QuestionVoteDelegate {
  /**
   * Find zero or one QuestionVote.
   * @param {FindOneQuestionVoteArgs} args - Arguments to find a QuestionVote
   * @example
   * // Get one QuestionVote
   * const questionVote = await prisma.questionVote.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneQuestionVoteArgs>(
    args: Subset<T, FindOneQuestionVoteArgs>
  ): CheckSelect<T, Prisma__QuestionVoteClient<QuestionVote | null>, Prisma__QuestionVoteClient<QuestionVoteGetPayload<T> | null>>
  /**
   * Find zero or more QuestionVotes.
   * @param {FindManyQuestionVoteArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all QuestionVotes
   * const questionVotes = await prisma.questionVote.findMany()
   * 
   * // Get first 10 QuestionVotes
   * const questionVotes = await prisma.questionVote.findMany({ take: 10 })
   * 
   * // Only select the `createdAt`
   * const questionVoteWithCreatedAtOnly = await prisma.questionVote.findMany({ select: { createdAt: true } })
   * 
  **/
  findMany<T extends FindManyQuestionVoteArgs>(
    args?: Subset<T, FindManyQuestionVoteArgs>
  ): CheckSelect<T, Promise<Array<QuestionVote>>, Promise<Array<QuestionVoteGetPayload<T>>>>
  /**
   * Create a QuestionVote.
   * @param {QuestionVoteCreateArgs} args - Arguments to create a QuestionVote.
   * @example
   * // Create one QuestionVote
   * const QuestionVote = await prisma.questionVote.create({
   *   data: {
   *     // ... data to create a QuestionVote
   *   }
   * })
   * 
  **/
  create<T extends QuestionVoteCreateArgs>(
    args: Subset<T, QuestionVoteCreateArgs>
  ): CheckSelect<T, Prisma__QuestionVoteClient<QuestionVote>, Prisma__QuestionVoteClient<QuestionVoteGetPayload<T>>>
  /**
   * Delete a QuestionVote.
   * @param {QuestionVoteDeleteArgs} args - Arguments to delete one QuestionVote.
   * @example
   * // Delete one QuestionVote
   * const QuestionVote = await prisma.questionVote.delete({
   *   where: {
   *     // ... filter to delete one QuestionVote
   *   }
   * })
   * 
  **/
  delete<T extends QuestionVoteDeleteArgs>(
    args: Subset<T, QuestionVoteDeleteArgs>
  ): CheckSelect<T, Prisma__QuestionVoteClient<QuestionVote>, Prisma__QuestionVoteClient<QuestionVoteGetPayload<T>>>
  /**
   * Update one QuestionVote.
   * @param {QuestionVoteUpdateArgs} args - Arguments to update one QuestionVote.
   * @example
   * // Update one QuestionVote
   * const questionVote = await prisma.questionVote.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends QuestionVoteUpdateArgs>(
    args: Subset<T, QuestionVoteUpdateArgs>
  ): CheckSelect<T, Prisma__QuestionVoteClient<QuestionVote>, Prisma__QuestionVoteClient<QuestionVoteGetPayload<T>>>
  /**
   * Delete zero or more QuestionVotes.
   * @param {QuestionVoteDeleteManyArgs} args - Arguments to filter QuestionVotes to delete.
   * @example
   * // Delete a few QuestionVotes
   * const { count } = await prisma.questionVote.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends QuestionVoteDeleteManyArgs>(
    args: Subset<T, QuestionVoteDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more QuestionVotes.
   * @param {QuestionVoteUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many QuestionVotes
   * const questionVote = await prisma.questionVote.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends QuestionVoteUpdateManyArgs>(
    args: Subset<T, QuestionVoteUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one QuestionVote.
   * @param {QuestionVoteUpsertArgs} args - Arguments to update or create a QuestionVote.
   * @example
   * // Update or create a QuestionVote
   * const questionVote = await prisma.questionVote.upsert({
   *   create: {
   *     // ... data to create a QuestionVote
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the QuestionVote we want to update
   *   }
   * })
  **/
  upsert<T extends QuestionVoteUpsertArgs>(
    args: Subset<T, QuestionVoteUpsertArgs>
  ): CheckSelect<T, Prisma__QuestionVoteClient<QuestionVote>, Prisma__QuestionVoteClient<QuestionVoteGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyQuestionVoteArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateQuestionVoteArgs>(args: Subset<T, AggregateQuestionVoteArgs>): Promise<GetQuestionVoteAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for QuestionVote.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__QuestionVoteClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  question<T extends QuestionArgs = {}>(args?: Subset<T, QuestionArgs>): CheckSelect<T, Prisma__QuestionClient<Question | null>, Prisma__QuestionClient<QuestionGetPayload<T> | null>>;

  user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * QuestionVote findOne
 */
export type FindOneQuestionVoteArgs = {
  /**
   * Select specific fields to fetch from the QuestionVote
  **/
  select?: QuestionVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionVoteInclude | null
  /**
   * Filter, which QuestionVote to fetch.
  **/
  where: QuestionVoteWhereUniqueInput
}


/**
 * QuestionVote findMany
 */
export type FindManyQuestionVoteArgs = {
  /**
   * Select specific fields to fetch from the QuestionVote
  **/
  select?: QuestionVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionVoteInclude | null
  /**
   * Filter, which QuestionVotes to fetch.
  **/
  where?: QuestionVoteWhereInput
  /**
   * Determine the order of the QuestionVotes to fetch.
  **/
  orderBy?: Enumerable<QuestionVoteOrderByInput>
  /**
   * Sets the position for listing QuestionVotes.
  **/
  cursor?: QuestionVoteWhereUniqueInput
  /**
   * The number of QuestionVotes to fetch. If negative number, it will take QuestionVotes before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` QuestionVotes.
  **/
  skip?: number
  distinct?: Enumerable<QuestionVoteDistinctFieldEnum>
}


/**
 * QuestionVote create
 */
export type QuestionVoteCreateArgs = {
  /**
   * Select specific fields to fetch from the QuestionVote
  **/
  select?: QuestionVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionVoteInclude | null
  /**
   * The data needed to create a QuestionVote.
  **/
  data: QuestionVoteCreateInput
}


/**
 * QuestionVote update
 */
export type QuestionVoteUpdateArgs = {
  /**
   * Select specific fields to fetch from the QuestionVote
  **/
  select?: QuestionVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionVoteInclude | null
  /**
   * The data needed to update a QuestionVote.
  **/
  data: QuestionVoteUpdateInput
  /**
   * Choose, which QuestionVote to update.
  **/
  where: QuestionVoteWhereUniqueInput
}


/**
 * QuestionVote updateMany
 */
export type QuestionVoteUpdateManyArgs = {
  data: QuestionVoteUpdateManyMutationInput
  where?: QuestionVoteWhereInput
}


/**
 * QuestionVote upsert
 */
export type QuestionVoteUpsertArgs = {
  /**
   * Select specific fields to fetch from the QuestionVote
  **/
  select?: QuestionVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionVoteInclude | null
  /**
   * The filter to search for the QuestionVote to update in case it exists.
  **/
  where: QuestionVoteWhereUniqueInput
  /**
   * In case the QuestionVote found by the `where` argument doesn't exist, create a new QuestionVote with this data.
  **/
  create: QuestionVoteCreateInput
  /**
   * In case the QuestionVote was found with the provided `where` argument, update it with this data.
  **/
  update: QuestionVoteUpdateInput
}


/**
 * QuestionVote delete
 */
export type QuestionVoteDeleteArgs = {
  /**
   * Select specific fields to fetch from the QuestionVote
  **/
  select?: QuestionVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionVoteInclude | null
  /**
   * Filter which QuestionVote to delete.
  **/
  where: QuestionVoteWhereUniqueInput
}


/**
 * QuestionVote deleteMany
 */
export type QuestionVoteDeleteManyArgs = {
  where?: QuestionVoteWhereInput
}


/**
 * QuestionVote without action
 */
export type QuestionVoteArgs = {
  /**
   * Select specific fields to fetch from the QuestionVote
  **/
  select?: QuestionVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionVoteInclude | null
}



/**
 * Model QuestionClick
 */

export type QuestionClick = {
  createdAt: Date
  updatedAt: Date
  questionId: string
  userId: string
}


export type AggregateQuestionClick = {
  count: number
}



export type AggregateQuestionClickArgs = {
  where?: QuestionClickWhereInput
  orderBy?: Enumerable<QuestionClickOrderByInput>
  cursor?: QuestionClickWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<QuestionClickDistinctFieldEnum>
  count?: true
}

export type GetQuestionClickAggregateType<T extends AggregateQuestionClickArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type QuestionClickSelect = {
  createdAt?: boolean
  updatedAt?: boolean
  question?: boolean | QuestionArgs
  questionId?: boolean
  user?: boolean | UserArgs
  userId?: boolean
}

export type QuestionClickInclude = {
  question?: boolean | QuestionArgs
  user?: boolean | UserArgs
}

export type QuestionClickGetPayload<
  S extends boolean | null | undefined | QuestionClickArgs,
  U = keyof S
> = S extends true
  ? QuestionClick
  : S extends undefined
  ? never
  : S extends QuestionClickArgs | FindManyQuestionClickArgs
  ? 'include' extends U
    ? QuestionClick  & {
      [P in TrueKeys<S['include']>]:
      P extends 'question'
      ? QuestionGetPayload<S['include'][P]> :
      P extends 'user'
      ? UserGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof QuestionClick ? QuestionClick[P]
: 
      P extends 'question'
      ? QuestionGetPayload<S['select'][P]> :
      P extends 'user'
      ? UserGetPayload<S['select'][P]> : never
    }
  : QuestionClick
: QuestionClick


export interface QuestionClickDelegate {
  /**
   * Find zero or one QuestionClick.
   * @param {FindOneQuestionClickArgs} args - Arguments to find a QuestionClick
   * @example
   * // Get one QuestionClick
   * const questionClick = await prisma.questionClick.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneQuestionClickArgs>(
    args: Subset<T, FindOneQuestionClickArgs>
  ): CheckSelect<T, Prisma__QuestionClickClient<QuestionClick | null>, Prisma__QuestionClickClient<QuestionClickGetPayload<T> | null>>
  /**
   * Find zero or more QuestionClicks.
   * @param {FindManyQuestionClickArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all QuestionClicks
   * const questionClicks = await prisma.questionClick.findMany()
   * 
   * // Get first 10 QuestionClicks
   * const questionClicks = await prisma.questionClick.findMany({ take: 10 })
   * 
   * // Only select the `createdAt`
   * const questionClickWithCreatedAtOnly = await prisma.questionClick.findMany({ select: { createdAt: true } })
   * 
  **/
  findMany<T extends FindManyQuestionClickArgs>(
    args?: Subset<T, FindManyQuestionClickArgs>
  ): CheckSelect<T, Promise<Array<QuestionClick>>, Promise<Array<QuestionClickGetPayload<T>>>>
  /**
   * Create a QuestionClick.
   * @param {QuestionClickCreateArgs} args - Arguments to create a QuestionClick.
   * @example
   * // Create one QuestionClick
   * const QuestionClick = await prisma.questionClick.create({
   *   data: {
   *     // ... data to create a QuestionClick
   *   }
   * })
   * 
  **/
  create<T extends QuestionClickCreateArgs>(
    args: Subset<T, QuestionClickCreateArgs>
  ): CheckSelect<T, Prisma__QuestionClickClient<QuestionClick>, Prisma__QuestionClickClient<QuestionClickGetPayload<T>>>
  /**
   * Delete a QuestionClick.
   * @param {QuestionClickDeleteArgs} args - Arguments to delete one QuestionClick.
   * @example
   * // Delete one QuestionClick
   * const QuestionClick = await prisma.questionClick.delete({
   *   where: {
   *     // ... filter to delete one QuestionClick
   *   }
   * })
   * 
  **/
  delete<T extends QuestionClickDeleteArgs>(
    args: Subset<T, QuestionClickDeleteArgs>
  ): CheckSelect<T, Prisma__QuestionClickClient<QuestionClick>, Prisma__QuestionClickClient<QuestionClickGetPayload<T>>>
  /**
   * Update one QuestionClick.
   * @param {QuestionClickUpdateArgs} args - Arguments to update one QuestionClick.
   * @example
   * // Update one QuestionClick
   * const questionClick = await prisma.questionClick.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends QuestionClickUpdateArgs>(
    args: Subset<T, QuestionClickUpdateArgs>
  ): CheckSelect<T, Prisma__QuestionClickClient<QuestionClick>, Prisma__QuestionClickClient<QuestionClickGetPayload<T>>>
  /**
   * Delete zero or more QuestionClicks.
   * @param {QuestionClickDeleteManyArgs} args - Arguments to filter QuestionClicks to delete.
   * @example
   * // Delete a few QuestionClicks
   * const { count } = await prisma.questionClick.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends QuestionClickDeleteManyArgs>(
    args: Subset<T, QuestionClickDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more QuestionClicks.
   * @param {QuestionClickUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many QuestionClicks
   * const questionClick = await prisma.questionClick.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends QuestionClickUpdateManyArgs>(
    args: Subset<T, QuestionClickUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one QuestionClick.
   * @param {QuestionClickUpsertArgs} args - Arguments to update or create a QuestionClick.
   * @example
   * // Update or create a QuestionClick
   * const questionClick = await prisma.questionClick.upsert({
   *   create: {
   *     // ... data to create a QuestionClick
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the QuestionClick we want to update
   *   }
   * })
  **/
  upsert<T extends QuestionClickUpsertArgs>(
    args: Subset<T, QuestionClickUpsertArgs>
  ): CheckSelect<T, Prisma__QuestionClickClient<QuestionClick>, Prisma__QuestionClickClient<QuestionClickGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyQuestionClickArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateQuestionClickArgs>(args: Subset<T, AggregateQuestionClickArgs>): Promise<GetQuestionClickAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for QuestionClick.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__QuestionClickClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  question<T extends QuestionArgs = {}>(args?: Subset<T, QuestionArgs>): CheckSelect<T, Prisma__QuestionClient<Question | null>, Prisma__QuestionClient<QuestionGetPayload<T> | null>>;

  user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * QuestionClick findOne
 */
export type FindOneQuestionClickArgs = {
  /**
   * Select specific fields to fetch from the QuestionClick
  **/
  select?: QuestionClickSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionClickInclude | null
  /**
   * Filter, which QuestionClick to fetch.
  **/
  where: QuestionClickWhereUniqueInput
}


/**
 * QuestionClick findMany
 */
export type FindManyQuestionClickArgs = {
  /**
   * Select specific fields to fetch from the QuestionClick
  **/
  select?: QuestionClickSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionClickInclude | null
  /**
   * Filter, which QuestionClicks to fetch.
  **/
  where?: QuestionClickWhereInput
  /**
   * Determine the order of the QuestionClicks to fetch.
  **/
  orderBy?: Enumerable<QuestionClickOrderByInput>
  /**
   * Sets the position for listing QuestionClicks.
  **/
  cursor?: QuestionClickWhereUniqueInput
  /**
   * The number of QuestionClicks to fetch. If negative number, it will take QuestionClicks before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` QuestionClicks.
  **/
  skip?: number
  distinct?: Enumerable<QuestionClickDistinctFieldEnum>
}


/**
 * QuestionClick create
 */
export type QuestionClickCreateArgs = {
  /**
   * Select specific fields to fetch from the QuestionClick
  **/
  select?: QuestionClickSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionClickInclude | null
  /**
   * The data needed to create a QuestionClick.
  **/
  data: QuestionClickCreateInput
}


/**
 * QuestionClick update
 */
export type QuestionClickUpdateArgs = {
  /**
   * Select specific fields to fetch from the QuestionClick
  **/
  select?: QuestionClickSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionClickInclude | null
  /**
   * The data needed to update a QuestionClick.
  **/
  data: QuestionClickUpdateInput
  /**
   * Choose, which QuestionClick to update.
  **/
  where: QuestionClickWhereUniqueInput
}


/**
 * QuestionClick updateMany
 */
export type QuestionClickUpdateManyArgs = {
  data: QuestionClickUpdateManyMutationInput
  where?: QuestionClickWhereInput
}


/**
 * QuestionClick upsert
 */
export type QuestionClickUpsertArgs = {
  /**
   * Select specific fields to fetch from the QuestionClick
  **/
  select?: QuestionClickSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionClickInclude | null
  /**
   * The filter to search for the QuestionClick to update in case it exists.
  **/
  where: QuestionClickWhereUniqueInput
  /**
   * In case the QuestionClick found by the `where` argument doesn't exist, create a new QuestionClick with this data.
  **/
  create: QuestionClickCreateInput
  /**
   * In case the QuestionClick was found with the provided `where` argument, update it with this data.
  **/
  update: QuestionClickUpdateInput
}


/**
 * QuestionClick delete
 */
export type QuestionClickDeleteArgs = {
  /**
   * Select specific fields to fetch from the QuestionClick
  **/
  select?: QuestionClickSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionClickInclude | null
  /**
   * Filter which QuestionClick to delete.
  **/
  where: QuestionClickWhereUniqueInput
}


/**
 * QuestionClick deleteMany
 */
export type QuestionClickDeleteManyArgs = {
  where?: QuestionClickWhereInput
}


/**
 * QuestionClick without action
 */
export type QuestionClickArgs = {
  /**
   * Select specific fields to fetch from the QuestionClick
  **/
  select?: QuestionClickSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionClickInclude | null
}



/**
 * Model Answer
 */

export type Answer = {
  id: string
  createdAt: Date
  updatedAt: Date
  content: string
  questionId: string
  deletedAt: Date | null
  userId: string
}


export type AggregateAnswer = {
  count: number
}



export type AggregateAnswerArgs = {
  where?: AnswerWhereInput
  orderBy?: Enumerable<AnswerOrderByInput>
  cursor?: AnswerWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AnswerDistinctFieldEnum>
  count?: true
}

export type GetAnswerAggregateType<T extends AggregateAnswerArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type AnswerSelect = {
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  content?: boolean
  votes?: boolean | FindManyAnswerVoteArgs
  question?: boolean | QuestionArgs
  questionId?: boolean
  deletedAt?: boolean
  user?: boolean | UserArgs
  userId?: boolean
}

export type AnswerInclude = {
  votes?: boolean | FindManyAnswerVoteArgs
  question?: boolean | QuestionArgs
  user?: boolean | UserArgs
}

export type AnswerGetPayload<
  S extends boolean | null | undefined | AnswerArgs,
  U = keyof S
> = S extends true
  ? Answer
  : S extends undefined
  ? never
  : S extends AnswerArgs | FindManyAnswerArgs
  ? 'include' extends U
    ? Answer  & {
      [P in TrueKeys<S['include']>]:
      P extends 'votes'
      ? Array<AnswerVoteGetPayload<S['include'][P]>> :
      P extends 'question'
      ? QuestionGetPayload<S['include'][P]> :
      P extends 'user'
      ? UserGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Answer ? Answer[P]
: 
      P extends 'votes'
      ? Array<AnswerVoteGetPayload<S['select'][P]>> :
      P extends 'question'
      ? QuestionGetPayload<S['select'][P]> :
      P extends 'user'
      ? UserGetPayload<S['select'][P]> : never
    }
  : Answer
: Answer


export interface AnswerDelegate {
  /**
   * Find zero or one Answer.
   * @param {FindOneAnswerArgs} args - Arguments to find a Answer
   * @example
   * // Get one Answer
   * const answer = await prisma.answer.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAnswerArgs>(
    args: Subset<T, FindOneAnswerArgs>
  ): CheckSelect<T, Prisma__AnswerClient<Answer | null>, Prisma__AnswerClient<AnswerGetPayload<T> | null>>
  /**
   * Find zero or more Answers.
   * @param {FindManyAnswerArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Answers
   * const answers = await prisma.answer.findMany()
   * 
   * // Get first 10 Answers
   * const answers = await prisma.answer.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAnswerArgs>(
    args?: Subset<T, FindManyAnswerArgs>
  ): CheckSelect<T, Promise<Array<Answer>>, Promise<Array<AnswerGetPayload<T>>>>
  /**
   * Create a Answer.
   * @param {AnswerCreateArgs} args - Arguments to create a Answer.
   * @example
   * // Create one Answer
   * const Answer = await prisma.answer.create({
   *   data: {
   *     // ... data to create a Answer
   *   }
   * })
   * 
  **/
  create<T extends AnswerCreateArgs>(
    args: Subset<T, AnswerCreateArgs>
  ): CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>>
  /**
   * Delete a Answer.
   * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
   * @example
   * // Delete one Answer
   * const Answer = await prisma.answer.delete({
   *   where: {
   *     // ... filter to delete one Answer
   *   }
   * })
   * 
  **/
  delete<T extends AnswerDeleteArgs>(
    args: Subset<T, AnswerDeleteArgs>
  ): CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>>
  /**
   * Update one Answer.
   * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
   * @example
   * // Update one Answer
   * const answer = await prisma.answer.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AnswerUpdateArgs>(
    args: Subset<T, AnswerUpdateArgs>
  ): CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>>
  /**
   * Delete zero or more Answers.
   * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
   * @example
   * // Delete a few Answers
   * const { count } = await prisma.answer.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AnswerDeleteManyArgs>(
    args: Subset<T, AnswerDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Answers.
   * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Answers
   * const answer = await prisma.answer.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AnswerUpdateManyArgs>(
    args: Subset<T, AnswerUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Answer.
   * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
   * @example
   * // Update or create a Answer
   * const answer = await prisma.answer.upsert({
   *   create: {
   *     // ... data to create a Answer
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Answer we want to update
   *   }
   * })
  **/
  upsert<T extends AnswerUpsertArgs>(
    args: Subset<T, AnswerUpsertArgs>
  ): CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAnswerArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateAnswerArgs>(args: Subset<T, AggregateAnswerArgs>): Promise<GetAnswerAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Answer.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AnswerClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  votes<T extends FindManyAnswerVoteArgs = {}>(args?: Subset<T, FindManyAnswerVoteArgs>): CheckSelect<T, Promise<Array<AnswerVote>>, Promise<Array<AnswerVoteGetPayload<T>>>>;

  question<T extends QuestionArgs = {}>(args?: Subset<T, QuestionArgs>): CheckSelect<T, Prisma__QuestionClient<Question | null>, Prisma__QuestionClient<QuestionGetPayload<T> | null>>;

  user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Answer findOne
 */
export type FindOneAnswerArgs = {
  /**
   * Select specific fields to fetch from the Answer
  **/
  select?: AnswerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerInclude | null
  /**
   * Filter, which Answer to fetch.
  **/
  where: AnswerWhereUniqueInput
}


/**
 * Answer findMany
 */
export type FindManyAnswerArgs = {
  /**
   * Select specific fields to fetch from the Answer
  **/
  select?: AnswerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerInclude | null
  /**
   * Filter, which Answers to fetch.
  **/
  where?: AnswerWhereInput
  /**
   * Determine the order of the Answers to fetch.
  **/
  orderBy?: Enumerable<AnswerOrderByInput>
  /**
   * Sets the position for listing Answers.
  **/
  cursor?: AnswerWhereUniqueInput
  /**
   * The number of Answers to fetch. If negative number, it will take Answers before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Answers.
  **/
  skip?: number
  distinct?: Enumerable<AnswerDistinctFieldEnum>
}


/**
 * Answer create
 */
export type AnswerCreateArgs = {
  /**
   * Select specific fields to fetch from the Answer
  **/
  select?: AnswerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerInclude | null
  /**
   * The data needed to create a Answer.
  **/
  data: AnswerCreateInput
}


/**
 * Answer update
 */
export type AnswerUpdateArgs = {
  /**
   * Select specific fields to fetch from the Answer
  **/
  select?: AnswerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerInclude | null
  /**
   * The data needed to update a Answer.
  **/
  data: AnswerUpdateInput
  /**
   * Choose, which Answer to update.
  **/
  where: AnswerWhereUniqueInput
}


/**
 * Answer updateMany
 */
export type AnswerUpdateManyArgs = {
  data: AnswerUpdateManyMutationInput
  where?: AnswerWhereInput
}


/**
 * Answer upsert
 */
export type AnswerUpsertArgs = {
  /**
   * Select specific fields to fetch from the Answer
  **/
  select?: AnswerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerInclude | null
  /**
   * The filter to search for the Answer to update in case it exists.
  **/
  where: AnswerWhereUniqueInput
  /**
   * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
  **/
  create: AnswerCreateInput
  /**
   * In case the Answer was found with the provided `where` argument, update it with this data.
  **/
  update: AnswerUpdateInput
}


/**
 * Answer delete
 */
export type AnswerDeleteArgs = {
  /**
   * Select specific fields to fetch from the Answer
  **/
  select?: AnswerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerInclude | null
  /**
   * Filter which Answer to delete.
  **/
  where: AnswerWhereUniqueInput
}


/**
 * Answer deleteMany
 */
export type AnswerDeleteManyArgs = {
  where?: AnswerWhereInput
}


/**
 * Answer without action
 */
export type AnswerArgs = {
  /**
   * Select specific fields to fetch from the Answer
  **/
  select?: AnswerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerInclude | null
}



/**
 * Model AnswerVote
 */

export type AnswerVote = {
  createdAt: Date
  updatedAt: Date
  upDown: boolean
  answerId: string
  userId: string
}


export type AggregateAnswerVote = {
  count: number
}



export type AggregateAnswerVoteArgs = {
  where?: AnswerVoteWhereInput
  orderBy?: Enumerable<AnswerVoteOrderByInput>
  cursor?: AnswerVoteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AnswerVoteDistinctFieldEnum>
  count?: true
}

export type GetAnswerVoteAggregateType<T extends AggregateAnswerVoteArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type AnswerVoteSelect = {
  createdAt?: boolean
  updatedAt?: boolean
  upDown?: boolean
  answer?: boolean | AnswerArgs
  answerId?: boolean
  user?: boolean | UserArgs
  userId?: boolean
}

export type AnswerVoteInclude = {
  answer?: boolean | AnswerArgs
  user?: boolean | UserArgs
}

export type AnswerVoteGetPayload<
  S extends boolean | null | undefined | AnswerVoteArgs,
  U = keyof S
> = S extends true
  ? AnswerVote
  : S extends undefined
  ? never
  : S extends AnswerVoteArgs | FindManyAnswerVoteArgs
  ? 'include' extends U
    ? AnswerVote  & {
      [P in TrueKeys<S['include']>]:
      P extends 'answer'
      ? AnswerGetPayload<S['include'][P]> :
      P extends 'user'
      ? UserGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof AnswerVote ? AnswerVote[P]
: 
      P extends 'answer'
      ? AnswerGetPayload<S['select'][P]> :
      P extends 'user'
      ? UserGetPayload<S['select'][P]> : never
    }
  : AnswerVote
: AnswerVote


export interface AnswerVoteDelegate {
  /**
   * Find zero or one AnswerVote.
   * @param {FindOneAnswerVoteArgs} args - Arguments to find a AnswerVote
   * @example
   * // Get one AnswerVote
   * const answerVote = await prisma.answerVote.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAnswerVoteArgs>(
    args: Subset<T, FindOneAnswerVoteArgs>
  ): CheckSelect<T, Prisma__AnswerVoteClient<AnswerVote | null>, Prisma__AnswerVoteClient<AnswerVoteGetPayload<T> | null>>
  /**
   * Find zero or more AnswerVotes.
   * @param {FindManyAnswerVoteArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all AnswerVotes
   * const answerVotes = await prisma.answerVote.findMany()
   * 
   * // Get first 10 AnswerVotes
   * const answerVotes = await prisma.answerVote.findMany({ take: 10 })
   * 
   * // Only select the `createdAt`
   * const answerVoteWithCreatedAtOnly = await prisma.answerVote.findMany({ select: { createdAt: true } })
   * 
  **/
  findMany<T extends FindManyAnswerVoteArgs>(
    args?: Subset<T, FindManyAnswerVoteArgs>
  ): CheckSelect<T, Promise<Array<AnswerVote>>, Promise<Array<AnswerVoteGetPayload<T>>>>
  /**
   * Create a AnswerVote.
   * @param {AnswerVoteCreateArgs} args - Arguments to create a AnswerVote.
   * @example
   * // Create one AnswerVote
   * const AnswerVote = await prisma.answerVote.create({
   *   data: {
   *     // ... data to create a AnswerVote
   *   }
   * })
   * 
  **/
  create<T extends AnswerVoteCreateArgs>(
    args: Subset<T, AnswerVoteCreateArgs>
  ): CheckSelect<T, Prisma__AnswerVoteClient<AnswerVote>, Prisma__AnswerVoteClient<AnswerVoteGetPayload<T>>>
  /**
   * Delete a AnswerVote.
   * @param {AnswerVoteDeleteArgs} args - Arguments to delete one AnswerVote.
   * @example
   * // Delete one AnswerVote
   * const AnswerVote = await prisma.answerVote.delete({
   *   where: {
   *     // ... filter to delete one AnswerVote
   *   }
   * })
   * 
  **/
  delete<T extends AnswerVoteDeleteArgs>(
    args: Subset<T, AnswerVoteDeleteArgs>
  ): CheckSelect<T, Prisma__AnswerVoteClient<AnswerVote>, Prisma__AnswerVoteClient<AnswerVoteGetPayload<T>>>
  /**
   * Update one AnswerVote.
   * @param {AnswerVoteUpdateArgs} args - Arguments to update one AnswerVote.
   * @example
   * // Update one AnswerVote
   * const answerVote = await prisma.answerVote.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AnswerVoteUpdateArgs>(
    args: Subset<T, AnswerVoteUpdateArgs>
  ): CheckSelect<T, Prisma__AnswerVoteClient<AnswerVote>, Prisma__AnswerVoteClient<AnswerVoteGetPayload<T>>>
  /**
   * Delete zero or more AnswerVotes.
   * @param {AnswerVoteDeleteManyArgs} args - Arguments to filter AnswerVotes to delete.
   * @example
   * // Delete a few AnswerVotes
   * const { count } = await prisma.answerVote.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AnswerVoteDeleteManyArgs>(
    args: Subset<T, AnswerVoteDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more AnswerVotes.
   * @param {AnswerVoteUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many AnswerVotes
   * const answerVote = await prisma.answerVote.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AnswerVoteUpdateManyArgs>(
    args: Subset<T, AnswerVoteUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one AnswerVote.
   * @param {AnswerVoteUpsertArgs} args - Arguments to update or create a AnswerVote.
   * @example
   * // Update or create a AnswerVote
   * const answerVote = await prisma.answerVote.upsert({
   *   create: {
   *     // ... data to create a AnswerVote
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the AnswerVote we want to update
   *   }
   * })
  **/
  upsert<T extends AnswerVoteUpsertArgs>(
    args: Subset<T, AnswerVoteUpsertArgs>
  ): CheckSelect<T, Prisma__AnswerVoteClient<AnswerVote>, Prisma__AnswerVoteClient<AnswerVoteGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAnswerVoteArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateAnswerVoteArgs>(args: Subset<T, AggregateAnswerVoteArgs>): Promise<GetAnswerVoteAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for AnswerVote.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AnswerVoteClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  answer<T extends AnswerArgs = {}>(args?: Subset<T, AnswerArgs>): CheckSelect<T, Prisma__AnswerClient<Answer | null>, Prisma__AnswerClient<AnswerGetPayload<T> | null>>;

  user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * AnswerVote findOne
 */
export type FindOneAnswerVoteArgs = {
  /**
   * Select specific fields to fetch from the AnswerVote
  **/
  select?: AnswerVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerVoteInclude | null
  /**
   * Filter, which AnswerVote to fetch.
  **/
  where: AnswerVoteWhereUniqueInput
}


/**
 * AnswerVote findMany
 */
export type FindManyAnswerVoteArgs = {
  /**
   * Select specific fields to fetch from the AnswerVote
  **/
  select?: AnswerVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerVoteInclude | null
  /**
   * Filter, which AnswerVotes to fetch.
  **/
  where?: AnswerVoteWhereInput
  /**
   * Determine the order of the AnswerVotes to fetch.
  **/
  orderBy?: Enumerable<AnswerVoteOrderByInput>
  /**
   * Sets the position for listing AnswerVotes.
  **/
  cursor?: AnswerVoteWhereUniqueInput
  /**
   * The number of AnswerVotes to fetch. If negative number, it will take AnswerVotes before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` AnswerVotes.
  **/
  skip?: number
  distinct?: Enumerable<AnswerVoteDistinctFieldEnum>
}


/**
 * AnswerVote create
 */
export type AnswerVoteCreateArgs = {
  /**
   * Select specific fields to fetch from the AnswerVote
  **/
  select?: AnswerVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerVoteInclude | null
  /**
   * The data needed to create a AnswerVote.
  **/
  data: AnswerVoteCreateInput
}


/**
 * AnswerVote update
 */
export type AnswerVoteUpdateArgs = {
  /**
   * Select specific fields to fetch from the AnswerVote
  **/
  select?: AnswerVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerVoteInclude | null
  /**
   * The data needed to update a AnswerVote.
  **/
  data: AnswerVoteUpdateInput
  /**
   * Choose, which AnswerVote to update.
  **/
  where: AnswerVoteWhereUniqueInput
}


/**
 * AnswerVote updateMany
 */
export type AnswerVoteUpdateManyArgs = {
  data: AnswerVoteUpdateManyMutationInput
  where?: AnswerVoteWhereInput
}


/**
 * AnswerVote upsert
 */
export type AnswerVoteUpsertArgs = {
  /**
   * Select specific fields to fetch from the AnswerVote
  **/
  select?: AnswerVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerVoteInclude | null
  /**
   * The filter to search for the AnswerVote to update in case it exists.
  **/
  where: AnswerVoteWhereUniqueInput
  /**
   * In case the AnswerVote found by the `where` argument doesn't exist, create a new AnswerVote with this data.
  **/
  create: AnswerVoteCreateInput
  /**
   * In case the AnswerVote was found with the provided `where` argument, update it with this data.
  **/
  update: AnswerVoteUpdateInput
}


/**
 * AnswerVote delete
 */
export type AnswerVoteDeleteArgs = {
  /**
   * Select specific fields to fetch from the AnswerVote
  **/
  select?: AnswerVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerVoteInclude | null
  /**
   * Filter which AnswerVote to delete.
  **/
  where: AnswerVoteWhereUniqueInput
}


/**
 * AnswerVote deleteMany
 */
export type AnswerVoteDeleteManyArgs = {
  where?: AnswerVoteWhereInput
}


/**
 * AnswerVote without action
 */
export type AnswerVoteArgs = {
  /**
   * Select specific fields to fetch from the AnswerVote
  **/
  select?: AnswerVoteSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswerVoteInclude | null
}



/**
 * Model Chatroom
 */

export type Chatroom = {
  id: string
  createdAt: Date
  updatedAt: Date
}


export type AggregateChatroom = {
  count: number
}



export type AggregateChatroomArgs = {
  where?: ChatroomWhereInput
  orderBy?: Enumerable<ChatroomOrderByInput>
  cursor?: ChatroomWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ChatroomDistinctFieldEnum>
  count?: true
}

export type GetChatroomAggregateType<T extends AggregateChatroomArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type ChatroomSelect = {
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  messages?: boolean | FindManyMessageArgs
  users?: boolean | FindManyUserArgs
}

export type ChatroomInclude = {
  messages?: boolean | FindManyMessageArgs
  users?: boolean | FindManyUserArgs
}

export type ChatroomGetPayload<
  S extends boolean | null | undefined | ChatroomArgs,
  U = keyof S
> = S extends true
  ? Chatroom
  : S extends undefined
  ? never
  : S extends ChatroomArgs | FindManyChatroomArgs
  ? 'include' extends U
    ? Chatroom  & {
      [P in TrueKeys<S['include']>]:
      P extends 'messages'
      ? Array<MessageGetPayload<S['include'][P]>> :
      P extends 'users'
      ? Array<UserGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Chatroom ? Chatroom[P]
: 
      P extends 'messages'
      ? Array<MessageGetPayload<S['select'][P]>> :
      P extends 'users'
      ? Array<UserGetPayload<S['select'][P]>> : never
    }
  : Chatroom
: Chatroom


export interface ChatroomDelegate {
  /**
   * Find zero or one Chatroom.
   * @param {FindOneChatroomArgs} args - Arguments to find a Chatroom
   * @example
   * // Get one Chatroom
   * const chatroom = await prisma.chatroom.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneChatroomArgs>(
    args: Subset<T, FindOneChatroomArgs>
  ): CheckSelect<T, Prisma__ChatroomClient<Chatroom | null>, Prisma__ChatroomClient<ChatroomGetPayload<T> | null>>
  /**
   * Find zero or more Chatrooms.
   * @param {FindManyChatroomArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Chatrooms
   * const chatrooms = await prisma.chatroom.findMany()
   * 
   * // Get first 10 Chatrooms
   * const chatrooms = await prisma.chatroom.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const chatroomWithIdOnly = await prisma.chatroom.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyChatroomArgs>(
    args?: Subset<T, FindManyChatroomArgs>
  ): CheckSelect<T, Promise<Array<Chatroom>>, Promise<Array<ChatroomGetPayload<T>>>>
  /**
   * Create a Chatroom.
   * @param {ChatroomCreateArgs} args - Arguments to create a Chatroom.
   * @example
   * // Create one Chatroom
   * const Chatroom = await prisma.chatroom.create({
   *   data: {
   *     // ... data to create a Chatroom
   *   }
   * })
   * 
  **/
  create<T extends ChatroomCreateArgs>(
    args: Subset<T, ChatroomCreateArgs>
  ): CheckSelect<T, Prisma__ChatroomClient<Chatroom>, Prisma__ChatroomClient<ChatroomGetPayload<T>>>
  /**
   * Delete a Chatroom.
   * @param {ChatroomDeleteArgs} args - Arguments to delete one Chatroom.
   * @example
   * // Delete one Chatroom
   * const Chatroom = await prisma.chatroom.delete({
   *   where: {
   *     // ... filter to delete one Chatroom
   *   }
   * })
   * 
  **/
  delete<T extends ChatroomDeleteArgs>(
    args: Subset<T, ChatroomDeleteArgs>
  ): CheckSelect<T, Prisma__ChatroomClient<Chatroom>, Prisma__ChatroomClient<ChatroomGetPayload<T>>>
  /**
   * Update one Chatroom.
   * @param {ChatroomUpdateArgs} args - Arguments to update one Chatroom.
   * @example
   * // Update one Chatroom
   * const chatroom = await prisma.chatroom.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ChatroomUpdateArgs>(
    args: Subset<T, ChatroomUpdateArgs>
  ): CheckSelect<T, Prisma__ChatroomClient<Chatroom>, Prisma__ChatroomClient<ChatroomGetPayload<T>>>
  /**
   * Delete zero or more Chatrooms.
   * @param {ChatroomDeleteManyArgs} args - Arguments to filter Chatrooms to delete.
   * @example
   * // Delete a few Chatrooms
   * const { count } = await prisma.chatroom.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ChatroomDeleteManyArgs>(
    args: Subset<T, ChatroomDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Chatrooms.
   * @param {ChatroomUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Chatrooms
   * const chatroom = await prisma.chatroom.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ChatroomUpdateManyArgs>(
    args: Subset<T, ChatroomUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Chatroom.
   * @param {ChatroomUpsertArgs} args - Arguments to update or create a Chatroom.
   * @example
   * // Update or create a Chatroom
   * const chatroom = await prisma.chatroom.upsert({
   *   create: {
   *     // ... data to create a Chatroom
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Chatroom we want to update
   *   }
   * })
  **/
  upsert<T extends ChatroomUpsertArgs>(
    args: Subset<T, ChatroomUpsertArgs>
  ): CheckSelect<T, Prisma__ChatroomClient<Chatroom>, Prisma__ChatroomClient<ChatroomGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyChatroomArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateChatroomArgs>(args: Subset<T, AggregateChatroomArgs>): Promise<GetChatroomAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Chatroom.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ChatroomClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  messages<T extends FindManyMessageArgs = {}>(args?: Subset<T, FindManyMessageArgs>): CheckSelect<T, Promise<Array<Message>>, Promise<Array<MessageGetPayload<T>>>>;

  users<T extends FindManyUserArgs = {}>(args?: Subset<T, FindManyUserArgs>): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Chatroom findOne
 */
export type FindOneChatroomArgs = {
  /**
   * Select specific fields to fetch from the Chatroom
  **/
  select?: ChatroomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChatroomInclude | null
  /**
   * Filter, which Chatroom to fetch.
  **/
  where: ChatroomWhereUniqueInput
}


/**
 * Chatroom findMany
 */
export type FindManyChatroomArgs = {
  /**
   * Select specific fields to fetch from the Chatroom
  **/
  select?: ChatroomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChatroomInclude | null
  /**
   * Filter, which Chatrooms to fetch.
  **/
  where?: ChatroomWhereInput
  /**
   * Determine the order of the Chatrooms to fetch.
  **/
  orderBy?: Enumerable<ChatroomOrderByInput>
  /**
   * Sets the position for listing Chatrooms.
  **/
  cursor?: ChatroomWhereUniqueInput
  /**
   * The number of Chatrooms to fetch. If negative number, it will take Chatrooms before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Chatrooms.
  **/
  skip?: number
  distinct?: Enumerable<ChatroomDistinctFieldEnum>
}


/**
 * Chatroom create
 */
export type ChatroomCreateArgs = {
  /**
   * Select specific fields to fetch from the Chatroom
  **/
  select?: ChatroomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChatroomInclude | null
  /**
   * The data needed to create a Chatroom.
  **/
  data: ChatroomCreateInput
}


/**
 * Chatroom update
 */
export type ChatroomUpdateArgs = {
  /**
   * Select specific fields to fetch from the Chatroom
  **/
  select?: ChatroomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChatroomInclude | null
  /**
   * The data needed to update a Chatroom.
  **/
  data: ChatroomUpdateInput
  /**
   * Choose, which Chatroom to update.
  **/
  where: ChatroomWhereUniqueInput
}


/**
 * Chatroom updateMany
 */
export type ChatroomUpdateManyArgs = {
  data: ChatroomUpdateManyMutationInput
  where?: ChatroomWhereInput
}


/**
 * Chatroom upsert
 */
export type ChatroomUpsertArgs = {
  /**
   * Select specific fields to fetch from the Chatroom
  **/
  select?: ChatroomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChatroomInclude | null
  /**
   * The filter to search for the Chatroom to update in case it exists.
  **/
  where: ChatroomWhereUniqueInput
  /**
   * In case the Chatroom found by the `where` argument doesn't exist, create a new Chatroom with this data.
  **/
  create: ChatroomCreateInput
  /**
   * In case the Chatroom was found with the provided `where` argument, update it with this data.
  **/
  update: ChatroomUpdateInput
}


/**
 * Chatroom delete
 */
export type ChatroomDeleteArgs = {
  /**
   * Select specific fields to fetch from the Chatroom
  **/
  select?: ChatroomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChatroomInclude | null
  /**
   * Filter which Chatroom to delete.
  **/
  where: ChatroomWhereUniqueInput
}


/**
 * Chatroom deleteMany
 */
export type ChatroomDeleteManyArgs = {
  where?: ChatroomWhereInput
}


/**
 * Chatroom without action
 */
export type ChatroomArgs = {
  /**
   * Select specific fields to fetch from the Chatroom
  **/
  select?: ChatroomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChatroomInclude | null
}



/**
 * Model Message
 */

export type Message = {
  id: string
  createdAt: Date
  updatedAt: Date
  content: string
  userId: string
  chatroomId: string | null
}


export type AggregateMessage = {
  count: number
}



export type AggregateMessageArgs = {
  where?: MessageWhereInput
  orderBy?: Enumerable<MessageOrderByInput>
  cursor?: MessageWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MessageDistinctFieldEnum>
  count?: true
}

export type GetMessageAggregateType<T extends AggregateMessageArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type MessageSelect = {
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  content?: boolean
  user?: boolean | UserArgs
  userId?: boolean
  chatroom?: boolean | ChatroomArgs
  chatroomId?: boolean
}

export type MessageInclude = {
  user?: boolean | UserArgs
  chatroom?: boolean | ChatroomArgs
}

export type MessageGetPayload<
  S extends boolean | null | undefined | MessageArgs,
  U = keyof S
> = S extends true
  ? Message
  : S extends undefined
  ? never
  : S extends MessageArgs | FindManyMessageArgs
  ? 'include' extends U
    ? Message  & {
      [P in TrueKeys<S['include']>]:
      P extends 'user'
      ? UserGetPayload<S['include'][P]> :
      P extends 'chatroom'
      ? ChatroomGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Message ? Message[P]
: 
      P extends 'user'
      ? UserGetPayload<S['select'][P]> :
      P extends 'chatroom'
      ? ChatroomGetPayload<S['select'][P]> | null : never
    }
  : Message
: Message


export interface MessageDelegate {
  /**
   * Find zero or one Message.
   * @param {FindOneMessageArgs} args - Arguments to find a Message
   * @example
   * // Get one Message
   * const message = await prisma.message.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneMessageArgs>(
    args: Subset<T, FindOneMessageArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message | null>, Prisma__MessageClient<MessageGetPayload<T> | null>>
  /**
   * Find zero or more Messages.
   * @param {FindManyMessageArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Messages
   * const messages = await prisma.message.findMany()
   * 
   * // Get first 10 Messages
   * const messages = await prisma.message.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyMessageArgs>(
    args?: Subset<T, FindManyMessageArgs>
  ): CheckSelect<T, Promise<Array<Message>>, Promise<Array<MessageGetPayload<T>>>>
  /**
   * Create a Message.
   * @param {MessageCreateArgs} args - Arguments to create a Message.
   * @example
   * // Create one Message
   * const Message = await prisma.message.create({
   *   data: {
   *     // ... data to create a Message
   *   }
   * })
   * 
  **/
  create<T extends MessageCreateArgs>(
    args: Subset<T, MessageCreateArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>
  /**
   * Delete a Message.
   * @param {MessageDeleteArgs} args - Arguments to delete one Message.
   * @example
   * // Delete one Message
   * const Message = await prisma.message.delete({
   *   where: {
   *     // ... filter to delete one Message
   *   }
   * })
   * 
  **/
  delete<T extends MessageDeleteArgs>(
    args: Subset<T, MessageDeleteArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>
  /**
   * Update one Message.
   * @param {MessageUpdateArgs} args - Arguments to update one Message.
   * @example
   * // Update one Message
   * const message = await prisma.message.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends MessageUpdateArgs>(
    args: Subset<T, MessageUpdateArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>
  /**
   * Delete zero or more Messages.
   * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
   * @example
   * // Delete a few Messages
   * const { count } = await prisma.message.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends MessageDeleteManyArgs>(
    args: Subset<T, MessageDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Messages.
   * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Messages
   * const message = await prisma.message.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends MessageUpdateManyArgs>(
    args: Subset<T, MessageUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Message.
   * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
   * @example
   * // Update or create a Message
   * const message = await prisma.message.upsert({
   *   create: {
   *     // ... data to create a Message
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Message we want to update
   *   }
   * })
  **/
  upsert<T extends MessageUpsertArgs>(
    args: Subset<T, MessageUpsertArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyMessageArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateMessageArgs>(args: Subset<T, AggregateMessageArgs>): Promise<GetMessageAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Message.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__MessageClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  chatroom<T extends ChatroomArgs = {}>(args?: Subset<T, ChatroomArgs>): CheckSelect<T, Prisma__ChatroomClient<Chatroom | null>, Prisma__ChatroomClient<ChatroomGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Message findOne
 */
export type FindOneMessageArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * Filter, which Message to fetch.
  **/
  where: MessageWhereUniqueInput
}


/**
 * Message findMany
 */
export type FindManyMessageArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * Filter, which Messages to fetch.
  **/
  where?: MessageWhereInput
  /**
   * Determine the order of the Messages to fetch.
  **/
  orderBy?: Enumerable<MessageOrderByInput>
  /**
   * Sets the position for listing Messages.
  **/
  cursor?: MessageWhereUniqueInput
  /**
   * The number of Messages to fetch. If negative number, it will take Messages before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Messages.
  **/
  skip?: number
  distinct?: Enumerable<MessageDistinctFieldEnum>
}


/**
 * Message create
 */
export type MessageCreateArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * The data needed to create a Message.
  **/
  data: MessageCreateInput
}


/**
 * Message update
 */
export type MessageUpdateArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * The data needed to update a Message.
  **/
  data: MessageUpdateInput
  /**
   * Choose, which Message to update.
  **/
  where: MessageWhereUniqueInput
}


/**
 * Message updateMany
 */
export type MessageUpdateManyArgs = {
  data: MessageUpdateManyMutationInput
  where?: MessageWhereInput
}


/**
 * Message upsert
 */
export type MessageUpsertArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * The filter to search for the Message to update in case it exists.
  **/
  where: MessageWhereUniqueInput
  /**
   * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
  **/
  create: MessageCreateInput
  /**
   * In case the Message was found with the provided `where` argument, update it with this data.
  **/
  update: MessageUpdateInput
}


/**
 * Message delete
 */
export type MessageDeleteArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * Filter which Message to delete.
  **/
  where: MessageWhereUniqueInput
}


/**
 * Message deleteMany
 */
export type MessageDeleteManyArgs = {
  where?: MessageWhereInput
}


/**
 * Message without action
 */
export type MessageArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
}



/**
 * Deep Input Types
 */


export type UserWhereInput = {
  AND?: Enumerable<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: Enumerable<UserWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  name?: string | StringNullableFilter | null
  biography?: string | StringNullableFilter | null
  class?: string | StringNullableFilter | null
  major?: string | StringNullableFilter | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFilter
  linkedin?: string | StringNullableFilter | null
  facebook?: string | StringNullableFilter | null
  twitter?: string | StringNullableFilter | null
  instagram?: string | StringNullableFilter | null
  snapchat?: string | StringNullableFilter | null
  tiktok?: string | StringNullableFilter | null
  openToHelp?: boolean | BoolNullableFilter | null
  studentType?: StudentType | EnumStudentTypeFilter
  chatrooms?: ChatroomListRelationFilter
  questions?: QuestionListRelationFilter
  questionVotes?: QuestionVoteListRelationFilter
  questionClicks?: QuestionClickListRelationFilter
  answerVotes?: AnswerVoteListRelationFilter
  answers?: AnswerListRelationFilter
  messages?: MessageListRelationFilter
}

export type UserOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
  name?: SortOrder
  biography?: SortOrder
  class?: SortOrder
  major?: SortOrder
  profileVisibility?: SortOrder
  linkedin?: SortOrder
  facebook?: SortOrder
  twitter?: SortOrder
  instagram?: SortOrder
  snapchat?: SortOrder
  tiktok?: SortOrder
  openToHelp?: SortOrder
  studentType?: SortOrder
}

export type UserWhereUniqueInput = {
  id?: string
  name?: string | null
  biography?: string | null
}

export type CategoryWhereInput = {
  AND?: Enumerable<CategoryWhereInput>
  OR?: Array<CategoryWhereInput>
  NOT?: Enumerable<CategoryWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  questions?: QuestionListRelationFilter
}

export type CategoryOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
  name?: SortOrder
}

export type CategoryWhereUniqueInput = {
  id?: string
  name?: string
}

export type QuestionWhereInput = {
  AND?: Enumerable<QuestionWhereInput>
  OR?: Array<QuestionWhereInput>
  NOT?: Enumerable<QuestionWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  title?: string | StringFilter
  description?: string | StringNullableFilter | null
  votes?: QuestionVoteListRelationFilter
  clicks?: QuestionClickListRelationFilter
  answers?: AnswerListRelationFilter
  deletedAt?: Date | string | DateTimeNullableFilter | null
  user?: UserWhereInput | null
  userId?: string | StringFilter
  categories?: CategoryListRelationFilter
}

export type QuestionOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
  title?: SortOrder
  description?: SortOrder
  deletedAt?: SortOrder
  userId?: SortOrder
}

export type QuestionWhereUniqueInput = {
  id?: string
  title?: string
  description?: string | null
}

export type QuestionVoteWhereInput = {
  AND?: Enumerable<QuestionVoteWhereInput>
  OR?: Array<QuestionVoteWhereInput>
  NOT?: Enumerable<QuestionVoteWhereInput>
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  upDown?: boolean | BoolFilter
  question?: QuestionWhereInput | null
  questionId?: string | StringFilter
  user?: UserWhereInput | null
  userId?: string | StringFilter
}

export type QuestionVoteOrderByInput = {
  createdAt?: SortOrder
  updatedAt?: SortOrder
  upDown?: SortOrder
  questionId?: SortOrder
  userId?: SortOrder
}

export type QuestionVoteWhereUniqueInput = {
  questionId_userId?: QuestionIdUserIdCompoundUniqueInput
}

export type QuestionClickWhereInput = {
  AND?: Enumerable<QuestionClickWhereInput>
  OR?: Array<QuestionClickWhereInput>
  NOT?: Enumerable<QuestionClickWhereInput>
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  question?: QuestionWhereInput | null
  questionId?: string | StringFilter
  user?: UserWhereInput | null
  userId?: string | StringFilter
}

export type QuestionClickOrderByInput = {
  createdAt?: SortOrder
  updatedAt?: SortOrder
  questionId?: SortOrder
  userId?: SortOrder
}

export type QuestionClickWhereUniqueInput = {
  questionId_userId?: QuestionIdUserIdCompoundUniqueInput
}

export type AnswerWhereInput = {
  AND?: Enumerable<AnswerWhereInput>
  OR?: Array<AnswerWhereInput>
  NOT?: Enumerable<AnswerWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  content?: string | StringFilter
  votes?: AnswerVoteListRelationFilter
  question?: QuestionWhereInput | null
  questionId?: string | StringFilter
  deletedAt?: Date | string | DateTimeNullableFilter | null
  user?: UserWhereInput | null
  userId?: string | StringFilter
}

export type AnswerOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
  content?: SortOrder
  questionId?: SortOrder
  deletedAt?: SortOrder
  userId?: SortOrder
}

export type AnswerWhereUniqueInput = {
  id?: string
  content?: string
}

export type AnswerVoteWhereInput = {
  AND?: Enumerable<AnswerVoteWhereInput>
  OR?: Array<AnswerVoteWhereInput>
  NOT?: Enumerable<AnswerVoteWhereInput>
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  upDown?: boolean | BoolFilter
  answer?: AnswerWhereInput | null
  answerId?: string | StringFilter
  user?: UserWhereInput | null
  userId?: string | StringFilter
}

export type AnswerVoteOrderByInput = {
  createdAt?: SortOrder
  updatedAt?: SortOrder
  upDown?: SortOrder
  answerId?: SortOrder
  userId?: SortOrder
}

export type AnswerVoteWhereUniqueInput = {
  answerId_userId?: AnswerIdUserIdCompoundUniqueInput
}

export type ChatroomWhereInput = {
  AND?: Enumerable<ChatroomWhereInput>
  OR?: Array<ChatroomWhereInput>
  NOT?: Enumerable<ChatroomWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  messages?: MessageListRelationFilter
  users?: UserListRelationFilter
}

export type ChatroomOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
}

export type ChatroomWhereUniqueInput = {
  id?: string
}

export type MessageWhereInput = {
  AND?: Enumerable<MessageWhereInput>
  OR?: Array<MessageWhereInput>
  NOT?: Enumerable<MessageWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  content?: string | StringFilter
  user?: UserWhereInput | null
  userId?: string | StringFilter
  chatroom?: ChatroomWhereInput | null
  chatroomId?: string | StringNullableFilter | null
}

export type MessageOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
  content?: SortOrder
  userId?: SortOrder
  chatroomId?: SortOrder
}

export type MessageWhereUniqueInput = {
  id?: string
}

export type UserCreateInput = {
  id: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name?: string | null
  biography?: string | null
  class?: string | null
  major?: string | null
  profileVisibility?: ProfileVisibility
  linkedin?: string | null
  facebook?: string | null
  twitter?: string | null
  instagram?: string | null
  snapchat?: string | null
  tiktok?: string | null
  openToHelp?: boolean | null
  studentType?: StudentType
  chatrooms?: ChatroomCreateManyWithoutUsersInput
  questions?: QuestionCreateManyWithoutUserInput
  questionVotes?: QuestionVoteCreateManyWithoutUserInput
  questionClicks?: QuestionClickCreateManyWithoutUserInput
  answerVotes?: AnswerVoteCreateManyWithoutUserInput
  answers?: AnswerCreateManyWithoutUserInput
  messages?: MessageCreateManyWithoutUserInput
}

export type UserUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
  chatrooms?: ChatroomUpdateManyWithoutUsersInput
  questions?: QuestionUpdateManyWithoutUserInput
  questionVotes?: QuestionVoteUpdateManyWithoutUserInput
  questionClicks?: QuestionClickUpdateManyWithoutUserInput
  answerVotes?: AnswerVoteUpdateManyWithoutUserInput
  answers?: AnswerUpdateManyWithoutUserInput
  messages?: MessageUpdateManyWithoutUserInput
}

export type UserUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
}

export type CategoryCreateInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name: string
  questions?: QuestionCreateManyWithoutCategoriesInput
}

export type CategoryUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
  questions?: QuestionUpdateManyWithoutCategoriesInput
}

export type CategoryUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
}

export type QuestionCreateInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  title: string
  description?: string | null
  deletedAt?: Date | string | null
  votes?: QuestionVoteCreateManyWithoutQuestionInput
  clicks?: QuestionClickCreateManyWithoutQuestionInput
  answers?: AnswerCreateManyWithoutQuestionInput
  user: UserCreateOneWithoutQuestionsInput
  categories?: CategoryCreateManyWithoutQuestionsInput
}

export type QuestionUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  votes?: QuestionVoteUpdateManyWithoutQuestionInput
  clicks?: QuestionClickUpdateManyWithoutQuestionInput
  answers?: AnswerUpdateManyWithoutQuestionInput
  user?: UserUpdateOneRequiredWithoutQuestionsInput
  categories?: CategoryUpdateManyWithoutQuestionsInput
}

export type QuestionUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type QuestionVoteCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  upDown: boolean
  question: QuestionCreateOneWithoutVotesInput
  user: UserCreateOneWithoutQuestionVotesInput
}

export type QuestionVoteUpdateInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
  question?: QuestionUpdateOneRequiredWithoutVotesInput
  user?: UserUpdateOneRequiredWithoutQuestionVotesInput
}

export type QuestionVoteUpdateManyMutationInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
}

export type QuestionClickCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  question: QuestionCreateOneWithoutClicksInput
  user: UserCreateOneWithoutQuestionClicksInput
}

export type QuestionClickUpdateInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  question?: QuestionUpdateOneRequiredWithoutClicksInput
  user?: UserUpdateOneRequiredWithoutQuestionClicksInput
}

export type QuestionClickUpdateManyMutationInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
}

export type AnswerCreateInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  content: string
  deletedAt?: Date | string | null
  votes?: AnswerVoteCreateManyWithoutAnswerInput
  question: QuestionCreateOneWithoutAnswersInput
  user: UserCreateOneWithoutAnswersInput
}

export type AnswerUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  votes?: AnswerVoteUpdateManyWithoutAnswerInput
  question?: QuestionUpdateOneRequiredWithoutAnswersInput
  user?: UserUpdateOneRequiredWithoutAnswersInput
}

export type AnswerUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type AnswerVoteCreateInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  upDown: boolean
  answer: AnswerCreateOneWithoutVotesInput
  user: UserCreateOneWithoutAnswerVotesInput
}

export type AnswerVoteUpdateInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
  answer?: AnswerUpdateOneRequiredWithoutVotesInput
  user?: UserUpdateOneRequiredWithoutAnswerVotesInput
}

export type AnswerVoteUpdateManyMutationInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
}

export type ChatroomCreateInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  messages?: MessageCreateManyWithoutChatroomInput
  users?: UserCreateManyWithoutChatroomsInput
}

export type ChatroomUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  messages?: MessageUpdateManyWithoutChatroomInput
  users?: UserUpdateManyWithoutChatroomsInput
}

export type ChatroomUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
}

export type MessageCreateInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  content: string
  user: UserCreateOneWithoutMessagesInput
  chatroom?: ChatroomCreateOneWithoutMessagesInput
}

export type MessageUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  user?: UserUpdateOneRequiredWithoutMessagesInput
  chatroom?: ChatroomUpdateOneWithoutMessagesInput
}

export type MessageUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
}

export type StringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringFilter
}

export type DateTimeFilter = {
  equals?: Date | string
  in?: Enumerable<Date | string>
  notIn?: Enumerable<Date | string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeFilter
}

export type StringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
  not?: string | NestedStringNullableFilter | null
}

export type EnumProfileVisibilityFilter = {
  equals?: ProfileVisibility
  in?: Enumerable<ProfileVisibility>
  notIn?: Enumerable<ProfileVisibility>
  not?: ProfileVisibility | NestedEnumProfileVisibilityFilter
}

export type BoolNullableFilter = {
  equals?: boolean | null
  not?: boolean | NestedBoolNullableFilter | null
}

export type EnumStudentTypeFilter = {
  equals?: StudentType
  in?: Enumerable<StudentType>
  notIn?: Enumerable<StudentType>
  not?: StudentType | NestedEnumStudentTypeFilter
}

export type ChatroomListRelationFilter = {
  every?: ChatroomWhereInput
  some?: ChatroomWhereInput
  none?: ChatroomWhereInput
}

export type QuestionListRelationFilter = {
  every?: QuestionWhereInput
  some?: QuestionWhereInput
  none?: QuestionWhereInput
}

export type QuestionVoteListRelationFilter = {
  every?: QuestionVoteWhereInput
  some?: QuestionVoteWhereInput
  none?: QuestionVoteWhereInput
}

export type QuestionClickListRelationFilter = {
  every?: QuestionClickWhereInput
  some?: QuestionClickWhereInput
  none?: QuestionClickWhereInput
}

export type AnswerVoteListRelationFilter = {
  every?: AnswerVoteWhereInput
  some?: AnswerVoteWhereInput
  none?: AnswerVoteWhereInput
}

export type AnswerListRelationFilter = {
  every?: AnswerWhereInput
  some?: AnswerWhereInput
  none?: AnswerWhereInput
}

export type MessageListRelationFilter = {
  every?: MessageWhereInput
  some?: MessageWhereInput
  none?: MessageWhereInput
}

export type DateTimeNullableFilter = {
  equals?: Date | string | null
  in?: Enumerable<Date | string> | null
  notIn?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
  not?: Date | string | NestedDateTimeNullableFilter | null
}

export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}

export type CategoryListRelationFilter = {
  every?: CategoryWhereInput
  some?: CategoryWhereInput
  none?: CategoryWhereInput
}

export type BoolFilter = {
  equals?: boolean
  not?: boolean | NestedBoolFilter
}

export type QuestionRelationFilter = {
  is?: QuestionWhereInput | null
  isNot?: QuestionWhereInput | null
}

export type QuestionIdUserIdCompoundUniqueInput = {
  questionId: string
  userId: string
}

export type AnswerRelationFilter = {
  is?: AnswerWhereInput | null
  isNot?: AnswerWhereInput | null
}

export type AnswerIdUserIdCompoundUniqueInput = {
  answerId: string
  userId: string
}

export type UserListRelationFilter = {
  every?: UserWhereInput
  some?: UserWhereInput
  none?: UserWhereInput
}

export type ChatroomRelationFilter = {
  is?: ChatroomWhereInput | null
  isNot?: ChatroomWhereInput | null
}

export type ChatroomCreateManyWithoutUsersInput = {
  create?: Enumerable<ChatroomCreateWithoutUsersInput>
  connect?: Enumerable<ChatroomWhereUniqueInput>
}

export type QuestionCreateManyWithoutUserInput = {
  create?: Enumerable<QuestionCreateWithoutUserInput>
  connect?: Enumerable<QuestionWhereUniqueInput>
}

export type QuestionVoteCreateManyWithoutUserInput = {
  create?: Enumerable<QuestionVoteCreateWithoutUserInput>
  connect?: Enumerable<QuestionVoteWhereUniqueInput>
}

export type QuestionClickCreateManyWithoutUserInput = {
  create?: Enumerable<QuestionClickCreateWithoutUserInput>
  connect?: Enumerable<QuestionClickWhereUniqueInput>
}

export type AnswerVoteCreateManyWithoutUserInput = {
  create?: Enumerable<AnswerVoteCreateWithoutUserInput>
  connect?: Enumerable<AnswerVoteWhereUniqueInput>
}

export type AnswerCreateManyWithoutUserInput = {
  create?: Enumerable<AnswerCreateWithoutUserInput>
  connect?: Enumerable<AnswerWhereUniqueInput>
}

export type MessageCreateManyWithoutUserInput = {
  create?: Enumerable<MessageCreateWithoutUserInput>
  connect?: Enumerable<MessageWhereUniqueInput>
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type DateTimeFieldUpdateOperationsInput = {
  set?: Date | string
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type EnumProfileVisibilityFieldUpdateOperationsInput = {
  set?: ProfileVisibility
}

export type NullableBoolFieldUpdateOperationsInput = {
  set?: boolean | null
}

export type EnumStudentTypeFieldUpdateOperationsInput = {
  set?: StudentType
}

export type ChatroomUpdateManyWithoutUsersInput = {
  create?: Enumerable<ChatroomCreateWithoutUsersInput>
  connect?: Enumerable<ChatroomWhereUniqueInput>
  set?: Enumerable<ChatroomWhereUniqueInput>
  disconnect?: Enumerable<ChatroomWhereUniqueInput>
  delete?: Enumerable<ChatroomWhereUniqueInput>
  update?: Enumerable<ChatroomUpdateWithWhereUniqueWithoutUsersInput>
  updateMany?: Enumerable<ChatroomUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ChatroomScalarWhereInput>
  upsert?: Enumerable<ChatroomUpsertWithWhereUniqueWithoutUsersInput>
}

export type QuestionUpdateManyWithoutUserInput = {
  create?: Enumerable<QuestionCreateWithoutUserInput>
  connect?: Enumerable<QuestionWhereUniqueInput>
  set?: Enumerable<QuestionWhereUniqueInput>
  disconnect?: Enumerable<QuestionWhereUniqueInput>
  delete?: Enumerable<QuestionWhereUniqueInput>
  update?: Enumerable<QuestionUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<QuestionUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<QuestionScalarWhereInput>
  upsert?: Enumerable<QuestionUpsertWithWhereUniqueWithoutUserInput>
}

export type QuestionVoteUpdateManyWithoutUserInput = {
  create?: Enumerable<QuestionVoteCreateWithoutUserInput>
  connect?: Enumerable<QuestionVoteWhereUniqueInput>
  set?: Enumerable<QuestionVoteWhereUniqueInput>
  disconnect?: Enumerable<QuestionVoteWhereUniqueInput>
  delete?: Enumerable<QuestionVoteWhereUniqueInput>
  update?: Enumerable<QuestionVoteUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<QuestionVoteUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<QuestionVoteScalarWhereInput>
  upsert?: Enumerable<QuestionVoteUpsertWithWhereUniqueWithoutUserInput>
}

export type QuestionClickUpdateManyWithoutUserInput = {
  create?: Enumerable<QuestionClickCreateWithoutUserInput>
  connect?: Enumerable<QuestionClickWhereUniqueInput>
  set?: Enumerable<QuestionClickWhereUniqueInput>
  disconnect?: Enumerable<QuestionClickWhereUniqueInput>
  delete?: Enumerable<QuestionClickWhereUniqueInput>
  update?: Enumerable<QuestionClickUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<QuestionClickUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<QuestionClickScalarWhereInput>
  upsert?: Enumerable<QuestionClickUpsertWithWhereUniqueWithoutUserInput>
}

export type AnswerVoteUpdateManyWithoutUserInput = {
  create?: Enumerable<AnswerVoteCreateWithoutUserInput>
  connect?: Enumerable<AnswerVoteWhereUniqueInput>
  set?: Enumerable<AnswerVoteWhereUniqueInput>
  disconnect?: Enumerable<AnswerVoteWhereUniqueInput>
  delete?: Enumerable<AnswerVoteWhereUniqueInput>
  update?: Enumerable<AnswerVoteUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<AnswerVoteUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AnswerVoteScalarWhereInput>
  upsert?: Enumerable<AnswerVoteUpsertWithWhereUniqueWithoutUserInput>
}

export type AnswerUpdateManyWithoutUserInput = {
  create?: Enumerable<AnswerCreateWithoutUserInput>
  connect?: Enumerable<AnswerWhereUniqueInput>
  set?: Enumerable<AnswerWhereUniqueInput>
  disconnect?: Enumerable<AnswerWhereUniqueInput>
  delete?: Enumerable<AnswerWhereUniqueInput>
  update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<AnswerUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AnswerScalarWhereInput>
  upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutUserInput>
}

export type MessageUpdateManyWithoutUserInput = {
  create?: Enumerable<MessageCreateWithoutUserInput>
  connect?: Enumerable<MessageWhereUniqueInput>
  set?: Enumerable<MessageWhereUniqueInput>
  disconnect?: Enumerable<MessageWhereUniqueInput>
  delete?: Enumerable<MessageWhereUniqueInput>
  update?: Enumerable<MessageUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<MessageUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<MessageScalarWhereInput>
  upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutUserInput>
}

export type QuestionCreateManyWithoutCategoriesInput = {
  create?: Enumerable<QuestionCreateWithoutCategoriesInput>
  connect?: Enumerable<QuestionWhereUniqueInput>
}

export type QuestionUpdateManyWithoutCategoriesInput = {
  create?: Enumerable<QuestionCreateWithoutCategoriesInput>
  connect?: Enumerable<QuestionWhereUniqueInput>
  set?: Enumerable<QuestionWhereUniqueInput>
  disconnect?: Enumerable<QuestionWhereUniqueInput>
  delete?: Enumerable<QuestionWhereUniqueInput>
  update?: Enumerable<QuestionUpdateWithWhereUniqueWithoutCategoriesInput>
  updateMany?: Enumerable<QuestionUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<QuestionScalarWhereInput>
  upsert?: Enumerable<QuestionUpsertWithWhereUniqueWithoutCategoriesInput>
}

export type QuestionVoteCreateManyWithoutQuestionInput = {
  create?: Enumerable<QuestionVoteCreateWithoutQuestionInput>
  connect?: Enumerable<QuestionVoteWhereUniqueInput>
}

export type QuestionClickCreateManyWithoutQuestionInput = {
  create?: Enumerable<QuestionClickCreateWithoutQuestionInput>
  connect?: Enumerable<QuestionClickWhereUniqueInput>
}

export type AnswerCreateManyWithoutQuestionInput = {
  create?: Enumerable<AnswerCreateWithoutQuestionInput>
  connect?: Enumerable<AnswerWhereUniqueInput>
}

export type UserCreateOneWithoutQuestionsInput = {
  create?: UserCreateWithoutQuestionsInput
  connect?: UserWhereUniqueInput
}

export type CategoryCreateManyWithoutQuestionsInput = {
  create?: Enumerable<CategoryCreateWithoutQuestionsInput>
  connect?: Enumerable<CategoryWhereUniqueInput>
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
}

export type QuestionVoteUpdateManyWithoutQuestionInput = {
  create?: Enumerable<QuestionVoteCreateWithoutQuestionInput>
  connect?: Enumerable<QuestionVoteWhereUniqueInput>
  set?: Enumerable<QuestionVoteWhereUniqueInput>
  disconnect?: Enumerable<QuestionVoteWhereUniqueInput>
  delete?: Enumerable<QuestionVoteWhereUniqueInput>
  update?: Enumerable<QuestionVoteUpdateWithWhereUniqueWithoutQuestionInput>
  updateMany?: Enumerable<QuestionVoteUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<QuestionVoteScalarWhereInput>
  upsert?: Enumerable<QuestionVoteUpsertWithWhereUniqueWithoutQuestionInput>
}

export type QuestionClickUpdateManyWithoutQuestionInput = {
  create?: Enumerable<QuestionClickCreateWithoutQuestionInput>
  connect?: Enumerable<QuestionClickWhereUniqueInput>
  set?: Enumerable<QuestionClickWhereUniqueInput>
  disconnect?: Enumerable<QuestionClickWhereUniqueInput>
  delete?: Enumerable<QuestionClickWhereUniqueInput>
  update?: Enumerable<QuestionClickUpdateWithWhereUniqueWithoutQuestionInput>
  updateMany?: Enumerable<QuestionClickUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<QuestionClickScalarWhereInput>
  upsert?: Enumerable<QuestionClickUpsertWithWhereUniqueWithoutQuestionInput>
}

export type AnswerUpdateManyWithoutQuestionInput = {
  create?: Enumerable<AnswerCreateWithoutQuestionInput>
  connect?: Enumerable<AnswerWhereUniqueInput>
  set?: Enumerable<AnswerWhereUniqueInput>
  disconnect?: Enumerable<AnswerWhereUniqueInput>
  delete?: Enumerable<AnswerWhereUniqueInput>
  update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutQuestionInput>
  updateMany?: Enumerable<AnswerUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AnswerScalarWhereInput>
  upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutQuestionInput>
}

export type UserUpdateOneRequiredWithoutQuestionsInput = {
  create?: UserCreateWithoutQuestionsInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutQuestionsDataInput
  upsert?: UserUpsertWithoutQuestionsInput
}

export type CategoryUpdateManyWithoutQuestionsInput = {
  create?: Enumerable<CategoryCreateWithoutQuestionsInput>
  connect?: Enumerable<CategoryWhereUniqueInput>
  set?: Enumerable<CategoryWhereUniqueInput>
  disconnect?: Enumerable<CategoryWhereUniqueInput>
  delete?: Enumerable<CategoryWhereUniqueInput>
  update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutQuestionsInput>
  updateMany?: Enumerable<CategoryUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<CategoryScalarWhereInput>
  upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutQuestionsInput>
}

export type QuestionCreateOneWithoutVotesInput = {
  create?: QuestionCreateWithoutVotesInput
  connect?: QuestionWhereUniqueInput
}

export type UserCreateOneWithoutQuestionVotesInput = {
  create?: UserCreateWithoutQuestionVotesInput
  connect?: UserWhereUniqueInput
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type QuestionUpdateOneRequiredWithoutVotesInput = {
  create?: QuestionCreateWithoutVotesInput
  connect?: QuestionWhereUniqueInput
  update?: QuestionUpdateWithoutVotesDataInput
  upsert?: QuestionUpsertWithoutVotesInput
}

export type UserUpdateOneRequiredWithoutQuestionVotesInput = {
  create?: UserCreateWithoutQuestionVotesInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutQuestionVotesDataInput
  upsert?: UserUpsertWithoutQuestionVotesInput
}

export type QuestionCreateOneWithoutClicksInput = {
  create?: QuestionCreateWithoutClicksInput
  connect?: QuestionWhereUniqueInput
}

export type UserCreateOneWithoutQuestionClicksInput = {
  create?: UserCreateWithoutQuestionClicksInput
  connect?: UserWhereUniqueInput
}

export type QuestionUpdateOneRequiredWithoutClicksInput = {
  create?: QuestionCreateWithoutClicksInput
  connect?: QuestionWhereUniqueInput
  update?: QuestionUpdateWithoutClicksDataInput
  upsert?: QuestionUpsertWithoutClicksInput
}

export type UserUpdateOneRequiredWithoutQuestionClicksInput = {
  create?: UserCreateWithoutQuestionClicksInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutQuestionClicksDataInput
  upsert?: UserUpsertWithoutQuestionClicksInput
}

export type AnswerVoteCreateManyWithoutAnswerInput = {
  create?: Enumerable<AnswerVoteCreateWithoutAnswerInput>
  connect?: Enumerable<AnswerVoteWhereUniqueInput>
}

export type QuestionCreateOneWithoutAnswersInput = {
  create?: QuestionCreateWithoutAnswersInput
  connect?: QuestionWhereUniqueInput
}

export type UserCreateOneWithoutAnswersInput = {
  create?: UserCreateWithoutAnswersInput
  connect?: UserWhereUniqueInput
}

export type AnswerVoteUpdateManyWithoutAnswerInput = {
  create?: Enumerable<AnswerVoteCreateWithoutAnswerInput>
  connect?: Enumerable<AnswerVoteWhereUniqueInput>
  set?: Enumerable<AnswerVoteWhereUniqueInput>
  disconnect?: Enumerable<AnswerVoteWhereUniqueInput>
  delete?: Enumerable<AnswerVoteWhereUniqueInput>
  update?: Enumerable<AnswerVoteUpdateWithWhereUniqueWithoutAnswerInput>
  updateMany?: Enumerable<AnswerVoteUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AnswerVoteScalarWhereInput>
  upsert?: Enumerable<AnswerVoteUpsertWithWhereUniqueWithoutAnswerInput>
}

export type QuestionUpdateOneRequiredWithoutAnswersInput = {
  create?: QuestionCreateWithoutAnswersInput
  connect?: QuestionWhereUniqueInput
  update?: QuestionUpdateWithoutAnswersDataInput
  upsert?: QuestionUpsertWithoutAnswersInput
}

export type UserUpdateOneRequiredWithoutAnswersInput = {
  create?: UserCreateWithoutAnswersInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutAnswersDataInput
  upsert?: UserUpsertWithoutAnswersInput
}

export type AnswerCreateOneWithoutVotesInput = {
  create?: AnswerCreateWithoutVotesInput
  connect?: AnswerWhereUniqueInput
}

export type UserCreateOneWithoutAnswerVotesInput = {
  create?: UserCreateWithoutAnswerVotesInput
  connect?: UserWhereUniqueInput
}

export type AnswerUpdateOneRequiredWithoutVotesInput = {
  create?: AnswerCreateWithoutVotesInput
  connect?: AnswerWhereUniqueInput
  update?: AnswerUpdateWithoutVotesDataInput
  upsert?: AnswerUpsertWithoutVotesInput
}

export type UserUpdateOneRequiredWithoutAnswerVotesInput = {
  create?: UserCreateWithoutAnswerVotesInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutAnswerVotesDataInput
  upsert?: UserUpsertWithoutAnswerVotesInput
}

export type MessageCreateManyWithoutChatroomInput = {
  create?: Enumerable<MessageCreateWithoutChatroomInput>
  connect?: Enumerable<MessageWhereUniqueInput>
}

export type UserCreateManyWithoutChatroomsInput = {
  create?: Enumerable<UserCreateWithoutChatroomsInput>
  connect?: Enumerable<UserWhereUniqueInput>
}

export type MessageUpdateManyWithoutChatroomInput = {
  create?: Enumerable<MessageCreateWithoutChatroomInput>
  connect?: Enumerable<MessageWhereUniqueInput>
  set?: Enumerable<MessageWhereUniqueInput>
  disconnect?: Enumerable<MessageWhereUniqueInput>
  delete?: Enumerable<MessageWhereUniqueInput>
  update?: Enumerable<MessageUpdateWithWhereUniqueWithoutChatroomInput>
  updateMany?: Enumerable<MessageUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<MessageScalarWhereInput>
  upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutChatroomInput>
}

export type UserUpdateManyWithoutChatroomsInput = {
  create?: Enumerable<UserCreateWithoutChatroomsInput>
  connect?: Enumerable<UserWhereUniqueInput>
  set?: Enumerable<UserWhereUniqueInput>
  disconnect?: Enumerable<UserWhereUniqueInput>
  delete?: Enumerable<UserWhereUniqueInput>
  update?: Enumerable<UserUpdateWithWhereUniqueWithoutChatroomsInput>
  updateMany?: Enumerable<UserUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<UserScalarWhereInput>
  upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutChatroomsInput>
}

export type UserCreateOneWithoutMessagesInput = {
  create?: UserCreateWithoutMessagesInput
  connect?: UserWhereUniqueInput
}

export type ChatroomCreateOneWithoutMessagesInput = {
  create?: ChatroomCreateWithoutMessagesInput
  connect?: ChatroomWhereUniqueInput
}

export type UserUpdateOneRequiredWithoutMessagesInput = {
  create?: UserCreateWithoutMessagesInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutMessagesDataInput
  upsert?: UserUpsertWithoutMessagesInput
}

export type ChatroomUpdateOneWithoutMessagesInput = {
  create?: ChatroomCreateWithoutMessagesInput
  connect?: ChatroomWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: ChatroomUpdateWithoutMessagesDataInput
  upsert?: ChatroomUpsertWithoutMessagesInput
}

export type NestedStringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: NestedStringFilter | null
}

export type NestedDateTimeFilter = {
  equals?: Date | string
  in?: Enumerable<Date | string>
  notIn?: Enumerable<Date | string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: NestedDateTimeFilter | null
}

export type NestedStringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
  not?: NestedStringNullableFilter | null
}

export type NestedEnumProfileVisibilityFilter = {
  equals?: ProfileVisibility
  in?: Enumerable<ProfileVisibility>
  notIn?: Enumerable<ProfileVisibility>
  not?: NestedEnumProfileVisibilityFilter | null
}

export type NestedBoolNullableFilter = {
  equals?: boolean | null
  not?: NestedBoolNullableFilter | null
}

export type NestedEnumStudentTypeFilter = {
  equals?: StudentType
  in?: Enumerable<StudentType>
  notIn?: Enumerable<StudentType>
  not?: NestedEnumStudentTypeFilter | null
}

export type NestedDateTimeNullableFilter = {
  equals?: Date | string | null
  in?: Enumerable<Date | string> | null
  notIn?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
  not?: NestedDateTimeNullableFilter | null
}

export type NestedBoolFilter = {
  equals?: boolean
  not?: NestedBoolFilter | null
}

export type ChatroomCreateWithoutUsersInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  messages?: MessageCreateManyWithoutChatroomInput
}

export type QuestionCreateWithoutUserInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  title: string
  description?: string | null
  deletedAt?: Date | string | null
  votes?: QuestionVoteCreateManyWithoutQuestionInput
  clicks?: QuestionClickCreateManyWithoutQuestionInput
  answers?: AnswerCreateManyWithoutQuestionInput
  categories?: CategoryCreateManyWithoutQuestionsInput
}

export type QuestionVoteCreateWithoutUserInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  upDown: boolean
  question: QuestionCreateOneWithoutVotesInput
}

export type QuestionClickCreateWithoutUserInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  question: QuestionCreateOneWithoutClicksInput
}

export type AnswerVoteCreateWithoutUserInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  upDown: boolean
  answer: AnswerCreateOneWithoutVotesInput
}

export type AnswerCreateWithoutUserInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  content: string
  deletedAt?: Date | string | null
  votes?: AnswerVoteCreateManyWithoutAnswerInput
  question: QuestionCreateOneWithoutAnswersInput
}

export type MessageCreateWithoutUserInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  content: string
  chatroom?: ChatroomCreateOneWithoutMessagesInput
}

export type ChatroomUpdateWithWhereUniqueWithoutUsersInput = {
  where: ChatroomWhereUniqueInput
  data: ChatroomUpdateWithoutUsersDataInput
}

export type ChatroomUpdateManyWithWhereNestedInput = {
  where: ChatroomScalarWhereInput
  data: ChatroomUpdateManyDataInput
}

export type ChatroomScalarWhereInput = {
  AND?: Enumerable<ChatroomScalarWhereInput>
  OR?: Array<ChatroomScalarWhereInput>
  NOT?: Enumerable<ChatroomScalarWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
}

export type ChatroomUpsertWithWhereUniqueWithoutUsersInput = {
  where: ChatroomWhereUniqueInput
  update: ChatroomUpdateWithoutUsersDataInput
  create: ChatroomCreateWithoutUsersInput
}

export type QuestionUpdateWithWhereUniqueWithoutUserInput = {
  where: QuestionWhereUniqueInput
  data: QuestionUpdateWithoutUserDataInput
}

export type QuestionUpdateManyWithWhereNestedInput = {
  where: QuestionScalarWhereInput
  data: QuestionUpdateManyDataInput
}

export type QuestionScalarWhereInput = {
  AND?: Enumerable<QuestionScalarWhereInput>
  OR?: Array<QuestionScalarWhereInput>
  NOT?: Enumerable<QuestionScalarWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  title?: string | StringFilter
  description?: string | StringNullableFilter | null
  deletedAt?: Date | string | DateTimeNullableFilter | null
  userId?: string | StringFilter
}

export type QuestionUpsertWithWhereUniqueWithoutUserInput = {
  where: QuestionWhereUniqueInput
  update: QuestionUpdateWithoutUserDataInput
  create: QuestionCreateWithoutUserInput
}

export type QuestionVoteUpdateWithWhereUniqueWithoutUserInput = {
  where: QuestionVoteWhereUniqueInput
  data: QuestionVoteUpdateWithoutUserDataInput
}

export type QuestionVoteUpdateManyWithWhereNestedInput = {
  where: QuestionVoteScalarWhereInput
  data: QuestionVoteUpdateManyDataInput
}

export type QuestionVoteScalarWhereInput = {
  AND?: Enumerable<QuestionVoteScalarWhereInput>
  OR?: Array<QuestionVoteScalarWhereInput>
  NOT?: Enumerable<QuestionVoteScalarWhereInput>
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  upDown?: boolean | BoolFilter
  questionId?: string | StringFilter
  userId?: string | StringFilter
}

export type QuestionVoteUpsertWithWhereUniqueWithoutUserInput = {
  where: QuestionVoteWhereUniqueInput
  update: QuestionVoteUpdateWithoutUserDataInput
  create: QuestionVoteCreateWithoutUserInput
}

export type QuestionClickUpdateWithWhereUniqueWithoutUserInput = {
  where: QuestionClickWhereUniqueInput
  data: QuestionClickUpdateWithoutUserDataInput
}

export type QuestionClickUpdateManyWithWhereNestedInput = {
  where: QuestionClickScalarWhereInput
  data: QuestionClickUpdateManyDataInput
}

export type QuestionClickScalarWhereInput = {
  AND?: Enumerable<QuestionClickScalarWhereInput>
  OR?: Array<QuestionClickScalarWhereInput>
  NOT?: Enumerable<QuestionClickScalarWhereInput>
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  questionId?: string | StringFilter
  userId?: string | StringFilter
}

export type QuestionClickUpsertWithWhereUniqueWithoutUserInput = {
  where: QuestionClickWhereUniqueInput
  update: QuestionClickUpdateWithoutUserDataInput
  create: QuestionClickCreateWithoutUserInput
}

export type AnswerVoteUpdateWithWhereUniqueWithoutUserInput = {
  where: AnswerVoteWhereUniqueInput
  data: AnswerVoteUpdateWithoutUserDataInput
}

export type AnswerVoteUpdateManyWithWhereNestedInput = {
  where: AnswerVoteScalarWhereInput
  data: AnswerVoteUpdateManyDataInput
}

export type AnswerVoteScalarWhereInput = {
  AND?: Enumerable<AnswerVoteScalarWhereInput>
  OR?: Array<AnswerVoteScalarWhereInput>
  NOT?: Enumerable<AnswerVoteScalarWhereInput>
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  upDown?: boolean | BoolFilter
  answerId?: string | StringFilter
  userId?: string | StringFilter
}

export type AnswerVoteUpsertWithWhereUniqueWithoutUserInput = {
  where: AnswerVoteWhereUniqueInput
  update: AnswerVoteUpdateWithoutUserDataInput
  create: AnswerVoteCreateWithoutUserInput
}

export type AnswerUpdateWithWhereUniqueWithoutUserInput = {
  where: AnswerWhereUniqueInput
  data: AnswerUpdateWithoutUserDataInput
}

export type AnswerUpdateManyWithWhereNestedInput = {
  where: AnswerScalarWhereInput
  data: AnswerUpdateManyDataInput
}

export type AnswerScalarWhereInput = {
  AND?: Enumerable<AnswerScalarWhereInput>
  OR?: Array<AnswerScalarWhereInput>
  NOT?: Enumerable<AnswerScalarWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  content?: string | StringFilter
  questionId?: string | StringFilter
  deletedAt?: Date | string | DateTimeNullableFilter | null
  userId?: string | StringFilter
}

export type AnswerUpsertWithWhereUniqueWithoutUserInput = {
  where: AnswerWhereUniqueInput
  update: AnswerUpdateWithoutUserDataInput
  create: AnswerCreateWithoutUserInput
}

export type MessageUpdateWithWhereUniqueWithoutUserInput = {
  where: MessageWhereUniqueInput
  data: MessageUpdateWithoutUserDataInput
}

export type MessageUpdateManyWithWhereNestedInput = {
  where: MessageScalarWhereInput
  data: MessageUpdateManyDataInput
}

export type MessageScalarWhereInput = {
  AND?: Enumerable<MessageScalarWhereInput>
  OR?: Array<MessageScalarWhereInput>
  NOT?: Enumerable<MessageScalarWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  content?: string | StringFilter
  userId?: string | StringFilter
  chatroomId?: string | StringNullableFilter | null
}

export type MessageUpsertWithWhereUniqueWithoutUserInput = {
  where: MessageWhereUniqueInput
  update: MessageUpdateWithoutUserDataInput
  create: MessageCreateWithoutUserInput
}

export type QuestionCreateWithoutCategoriesInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  title: string
  description?: string | null
  deletedAt?: Date | string | null
  votes?: QuestionVoteCreateManyWithoutQuestionInput
  clicks?: QuestionClickCreateManyWithoutQuestionInput
  answers?: AnswerCreateManyWithoutQuestionInput
  user: UserCreateOneWithoutQuestionsInput
}

export type QuestionUpdateWithWhereUniqueWithoutCategoriesInput = {
  where: QuestionWhereUniqueInput
  data: QuestionUpdateWithoutCategoriesDataInput
}

export type QuestionUpsertWithWhereUniqueWithoutCategoriesInput = {
  where: QuestionWhereUniqueInput
  update: QuestionUpdateWithoutCategoriesDataInput
  create: QuestionCreateWithoutCategoriesInput
}

export type QuestionVoteCreateWithoutQuestionInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  upDown: boolean
  user: UserCreateOneWithoutQuestionVotesInput
}

export type QuestionClickCreateWithoutQuestionInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  user: UserCreateOneWithoutQuestionClicksInput
}

export type AnswerCreateWithoutQuestionInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  content: string
  deletedAt?: Date | string | null
  votes?: AnswerVoteCreateManyWithoutAnswerInput
  user: UserCreateOneWithoutAnswersInput
}

export type UserCreateWithoutQuestionsInput = {
  id: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name?: string | null
  biography?: string | null
  class?: string | null
  major?: string | null
  profileVisibility?: ProfileVisibility
  linkedin?: string | null
  facebook?: string | null
  twitter?: string | null
  instagram?: string | null
  snapchat?: string | null
  tiktok?: string | null
  openToHelp?: boolean | null
  studentType?: StudentType
  chatrooms?: ChatroomCreateManyWithoutUsersInput
  questionVotes?: QuestionVoteCreateManyWithoutUserInput
  questionClicks?: QuestionClickCreateManyWithoutUserInput
  answerVotes?: AnswerVoteCreateManyWithoutUserInput
  answers?: AnswerCreateManyWithoutUserInput
  messages?: MessageCreateManyWithoutUserInput
}

export type CategoryCreateWithoutQuestionsInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name: string
}

export type QuestionVoteUpdateWithWhereUniqueWithoutQuestionInput = {
  where: QuestionVoteWhereUniqueInput
  data: QuestionVoteUpdateWithoutQuestionDataInput
}

export type QuestionVoteUpsertWithWhereUniqueWithoutQuestionInput = {
  where: QuestionVoteWhereUniqueInput
  update: QuestionVoteUpdateWithoutQuestionDataInput
  create: QuestionVoteCreateWithoutQuestionInput
}

export type QuestionClickUpdateWithWhereUniqueWithoutQuestionInput = {
  where: QuestionClickWhereUniqueInput
  data: QuestionClickUpdateWithoutQuestionDataInput
}

export type QuestionClickUpsertWithWhereUniqueWithoutQuestionInput = {
  where: QuestionClickWhereUniqueInput
  update: QuestionClickUpdateWithoutQuestionDataInput
  create: QuestionClickCreateWithoutQuestionInput
}

export type AnswerUpdateWithWhereUniqueWithoutQuestionInput = {
  where: AnswerWhereUniqueInput
  data: AnswerUpdateWithoutQuestionDataInput
}

export type AnswerUpsertWithWhereUniqueWithoutQuestionInput = {
  where: AnswerWhereUniqueInput
  update: AnswerUpdateWithoutQuestionDataInput
  create: AnswerCreateWithoutQuestionInput
}

export type UserUpdateWithoutQuestionsDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
  chatrooms?: ChatroomUpdateManyWithoutUsersInput
  questionVotes?: QuestionVoteUpdateManyWithoutUserInput
  questionClicks?: QuestionClickUpdateManyWithoutUserInput
  answerVotes?: AnswerVoteUpdateManyWithoutUserInput
  answers?: AnswerUpdateManyWithoutUserInput
  messages?: MessageUpdateManyWithoutUserInput
}

export type UserUpsertWithoutQuestionsInput = {
  update: UserUpdateWithoutQuestionsDataInput
  create: UserCreateWithoutQuestionsInput
}

export type CategoryUpdateWithWhereUniqueWithoutQuestionsInput = {
  where: CategoryWhereUniqueInput
  data: CategoryUpdateWithoutQuestionsDataInput
}

export type CategoryUpdateManyWithWhereNestedInput = {
  where: CategoryScalarWhereInput
  data: CategoryUpdateManyDataInput
}

export type CategoryScalarWhereInput = {
  AND?: Enumerable<CategoryScalarWhereInput>
  OR?: Array<CategoryScalarWhereInput>
  NOT?: Enumerable<CategoryScalarWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
}

export type CategoryUpsertWithWhereUniqueWithoutQuestionsInput = {
  where: CategoryWhereUniqueInput
  update: CategoryUpdateWithoutQuestionsDataInput
  create: CategoryCreateWithoutQuestionsInput
}

export type QuestionCreateWithoutVotesInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  title: string
  description?: string | null
  deletedAt?: Date | string | null
  clicks?: QuestionClickCreateManyWithoutQuestionInput
  answers?: AnswerCreateManyWithoutQuestionInput
  user: UserCreateOneWithoutQuestionsInput
  categories?: CategoryCreateManyWithoutQuestionsInput
}

export type UserCreateWithoutQuestionVotesInput = {
  id: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name?: string | null
  biography?: string | null
  class?: string | null
  major?: string | null
  profileVisibility?: ProfileVisibility
  linkedin?: string | null
  facebook?: string | null
  twitter?: string | null
  instagram?: string | null
  snapchat?: string | null
  tiktok?: string | null
  openToHelp?: boolean | null
  studentType?: StudentType
  chatrooms?: ChatroomCreateManyWithoutUsersInput
  questions?: QuestionCreateManyWithoutUserInput
  questionClicks?: QuestionClickCreateManyWithoutUserInput
  answerVotes?: AnswerVoteCreateManyWithoutUserInput
  answers?: AnswerCreateManyWithoutUserInput
  messages?: MessageCreateManyWithoutUserInput
}

export type QuestionUpdateWithoutVotesDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  clicks?: QuestionClickUpdateManyWithoutQuestionInput
  answers?: AnswerUpdateManyWithoutQuestionInput
  user?: UserUpdateOneRequiredWithoutQuestionsInput
  categories?: CategoryUpdateManyWithoutQuestionsInput
}

export type QuestionUpsertWithoutVotesInput = {
  update: QuestionUpdateWithoutVotesDataInput
  create: QuestionCreateWithoutVotesInput
}

export type UserUpdateWithoutQuestionVotesDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
  chatrooms?: ChatroomUpdateManyWithoutUsersInput
  questions?: QuestionUpdateManyWithoutUserInput
  questionClicks?: QuestionClickUpdateManyWithoutUserInput
  answerVotes?: AnswerVoteUpdateManyWithoutUserInput
  answers?: AnswerUpdateManyWithoutUserInput
  messages?: MessageUpdateManyWithoutUserInput
}

export type UserUpsertWithoutQuestionVotesInput = {
  update: UserUpdateWithoutQuestionVotesDataInput
  create: UserCreateWithoutQuestionVotesInput
}

export type QuestionCreateWithoutClicksInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  title: string
  description?: string | null
  deletedAt?: Date | string | null
  votes?: QuestionVoteCreateManyWithoutQuestionInput
  answers?: AnswerCreateManyWithoutQuestionInput
  user: UserCreateOneWithoutQuestionsInput
  categories?: CategoryCreateManyWithoutQuestionsInput
}

export type UserCreateWithoutQuestionClicksInput = {
  id: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name?: string | null
  biography?: string | null
  class?: string | null
  major?: string | null
  profileVisibility?: ProfileVisibility
  linkedin?: string | null
  facebook?: string | null
  twitter?: string | null
  instagram?: string | null
  snapchat?: string | null
  tiktok?: string | null
  openToHelp?: boolean | null
  studentType?: StudentType
  chatrooms?: ChatroomCreateManyWithoutUsersInput
  questions?: QuestionCreateManyWithoutUserInput
  questionVotes?: QuestionVoteCreateManyWithoutUserInput
  answerVotes?: AnswerVoteCreateManyWithoutUserInput
  answers?: AnswerCreateManyWithoutUserInput
  messages?: MessageCreateManyWithoutUserInput
}

export type QuestionUpdateWithoutClicksDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  votes?: QuestionVoteUpdateManyWithoutQuestionInput
  answers?: AnswerUpdateManyWithoutQuestionInput
  user?: UserUpdateOneRequiredWithoutQuestionsInput
  categories?: CategoryUpdateManyWithoutQuestionsInput
}

export type QuestionUpsertWithoutClicksInput = {
  update: QuestionUpdateWithoutClicksDataInput
  create: QuestionCreateWithoutClicksInput
}

export type UserUpdateWithoutQuestionClicksDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
  chatrooms?: ChatroomUpdateManyWithoutUsersInput
  questions?: QuestionUpdateManyWithoutUserInput
  questionVotes?: QuestionVoteUpdateManyWithoutUserInput
  answerVotes?: AnswerVoteUpdateManyWithoutUserInput
  answers?: AnswerUpdateManyWithoutUserInput
  messages?: MessageUpdateManyWithoutUserInput
}

export type UserUpsertWithoutQuestionClicksInput = {
  update: UserUpdateWithoutQuestionClicksDataInput
  create: UserCreateWithoutQuestionClicksInput
}

export type AnswerVoteCreateWithoutAnswerInput = {
  createdAt?: Date | string
  updatedAt?: Date | string
  upDown: boolean
  user: UserCreateOneWithoutAnswerVotesInput
}

export type QuestionCreateWithoutAnswersInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  title: string
  description?: string | null
  deletedAt?: Date | string | null
  votes?: QuestionVoteCreateManyWithoutQuestionInput
  clicks?: QuestionClickCreateManyWithoutQuestionInput
  user: UserCreateOneWithoutQuestionsInput
  categories?: CategoryCreateManyWithoutQuestionsInput
}

export type UserCreateWithoutAnswersInput = {
  id: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name?: string | null
  biography?: string | null
  class?: string | null
  major?: string | null
  profileVisibility?: ProfileVisibility
  linkedin?: string | null
  facebook?: string | null
  twitter?: string | null
  instagram?: string | null
  snapchat?: string | null
  tiktok?: string | null
  openToHelp?: boolean | null
  studentType?: StudentType
  chatrooms?: ChatroomCreateManyWithoutUsersInput
  questions?: QuestionCreateManyWithoutUserInput
  questionVotes?: QuestionVoteCreateManyWithoutUserInput
  questionClicks?: QuestionClickCreateManyWithoutUserInput
  answerVotes?: AnswerVoteCreateManyWithoutUserInput
  messages?: MessageCreateManyWithoutUserInput
}

export type AnswerVoteUpdateWithWhereUniqueWithoutAnswerInput = {
  where: AnswerVoteWhereUniqueInput
  data: AnswerVoteUpdateWithoutAnswerDataInput
}

export type AnswerVoteUpsertWithWhereUniqueWithoutAnswerInput = {
  where: AnswerVoteWhereUniqueInput
  update: AnswerVoteUpdateWithoutAnswerDataInput
  create: AnswerVoteCreateWithoutAnswerInput
}

export type QuestionUpdateWithoutAnswersDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  votes?: QuestionVoteUpdateManyWithoutQuestionInput
  clicks?: QuestionClickUpdateManyWithoutQuestionInput
  user?: UserUpdateOneRequiredWithoutQuestionsInput
  categories?: CategoryUpdateManyWithoutQuestionsInput
}

export type QuestionUpsertWithoutAnswersInput = {
  update: QuestionUpdateWithoutAnswersDataInput
  create: QuestionCreateWithoutAnswersInput
}

export type UserUpdateWithoutAnswersDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
  chatrooms?: ChatroomUpdateManyWithoutUsersInput
  questions?: QuestionUpdateManyWithoutUserInput
  questionVotes?: QuestionVoteUpdateManyWithoutUserInput
  questionClicks?: QuestionClickUpdateManyWithoutUserInput
  answerVotes?: AnswerVoteUpdateManyWithoutUserInput
  messages?: MessageUpdateManyWithoutUserInput
}

export type UserUpsertWithoutAnswersInput = {
  update: UserUpdateWithoutAnswersDataInput
  create: UserCreateWithoutAnswersInput
}

export type AnswerCreateWithoutVotesInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  content: string
  deletedAt?: Date | string | null
  question: QuestionCreateOneWithoutAnswersInput
  user: UserCreateOneWithoutAnswersInput
}

export type UserCreateWithoutAnswerVotesInput = {
  id: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name?: string | null
  biography?: string | null
  class?: string | null
  major?: string | null
  profileVisibility?: ProfileVisibility
  linkedin?: string | null
  facebook?: string | null
  twitter?: string | null
  instagram?: string | null
  snapchat?: string | null
  tiktok?: string | null
  openToHelp?: boolean | null
  studentType?: StudentType
  chatrooms?: ChatroomCreateManyWithoutUsersInput
  questions?: QuestionCreateManyWithoutUserInput
  questionVotes?: QuestionVoteCreateManyWithoutUserInput
  questionClicks?: QuestionClickCreateManyWithoutUserInput
  answers?: AnswerCreateManyWithoutUserInput
  messages?: MessageCreateManyWithoutUserInput
}

export type AnswerUpdateWithoutVotesDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  question?: QuestionUpdateOneRequiredWithoutAnswersInput
  user?: UserUpdateOneRequiredWithoutAnswersInput
}

export type AnswerUpsertWithoutVotesInput = {
  update: AnswerUpdateWithoutVotesDataInput
  create: AnswerCreateWithoutVotesInput
}

export type UserUpdateWithoutAnswerVotesDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
  chatrooms?: ChatroomUpdateManyWithoutUsersInput
  questions?: QuestionUpdateManyWithoutUserInput
  questionVotes?: QuestionVoteUpdateManyWithoutUserInput
  questionClicks?: QuestionClickUpdateManyWithoutUserInput
  answers?: AnswerUpdateManyWithoutUserInput
  messages?: MessageUpdateManyWithoutUserInput
}

export type UserUpsertWithoutAnswerVotesInput = {
  update: UserUpdateWithoutAnswerVotesDataInput
  create: UserCreateWithoutAnswerVotesInput
}

export type MessageCreateWithoutChatroomInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  content: string
  user: UserCreateOneWithoutMessagesInput
}

export type UserCreateWithoutChatroomsInput = {
  id: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name?: string | null
  biography?: string | null
  class?: string | null
  major?: string | null
  profileVisibility?: ProfileVisibility
  linkedin?: string | null
  facebook?: string | null
  twitter?: string | null
  instagram?: string | null
  snapchat?: string | null
  tiktok?: string | null
  openToHelp?: boolean | null
  studentType?: StudentType
  questions?: QuestionCreateManyWithoutUserInput
  questionVotes?: QuestionVoteCreateManyWithoutUserInput
  questionClicks?: QuestionClickCreateManyWithoutUserInput
  answerVotes?: AnswerVoteCreateManyWithoutUserInput
  answers?: AnswerCreateManyWithoutUserInput
  messages?: MessageCreateManyWithoutUserInput
}

export type MessageUpdateWithWhereUniqueWithoutChatroomInput = {
  where: MessageWhereUniqueInput
  data: MessageUpdateWithoutChatroomDataInput
}

export type MessageUpsertWithWhereUniqueWithoutChatroomInput = {
  where: MessageWhereUniqueInput
  update: MessageUpdateWithoutChatroomDataInput
  create: MessageCreateWithoutChatroomInput
}

export type UserUpdateWithWhereUniqueWithoutChatroomsInput = {
  where: UserWhereUniqueInput
  data: UserUpdateWithoutChatroomsDataInput
}

export type UserUpdateManyWithWhereNestedInput = {
  where: UserScalarWhereInput
  data: UserUpdateManyDataInput
}

export type UserScalarWhereInput = {
  AND?: Enumerable<UserScalarWhereInput>
  OR?: Array<UserScalarWhereInput>
  NOT?: Enumerable<UserScalarWhereInput>
  id?: string | StringFilter
  createdAt?: Date | string | DateTimeFilter
  updatedAt?: Date | string | DateTimeFilter
  name?: string | StringNullableFilter | null
  biography?: string | StringNullableFilter | null
  class?: string | StringNullableFilter | null
  major?: string | StringNullableFilter | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFilter
  linkedin?: string | StringNullableFilter | null
  facebook?: string | StringNullableFilter | null
  twitter?: string | StringNullableFilter | null
  instagram?: string | StringNullableFilter | null
  snapchat?: string | StringNullableFilter | null
  tiktok?: string | StringNullableFilter | null
  openToHelp?: boolean | BoolNullableFilter | null
  studentType?: StudentType | EnumStudentTypeFilter
}

export type UserUpsertWithWhereUniqueWithoutChatroomsInput = {
  where: UserWhereUniqueInput
  update: UserUpdateWithoutChatroomsDataInput
  create: UserCreateWithoutChatroomsInput
}

export type UserCreateWithoutMessagesInput = {
  id: string
  createdAt?: Date | string
  updatedAt?: Date | string
  name?: string | null
  biography?: string | null
  class?: string | null
  major?: string | null
  profileVisibility?: ProfileVisibility
  linkedin?: string | null
  facebook?: string | null
  twitter?: string | null
  instagram?: string | null
  snapchat?: string | null
  tiktok?: string | null
  openToHelp?: boolean | null
  studentType?: StudentType
  chatrooms?: ChatroomCreateManyWithoutUsersInput
  questions?: QuestionCreateManyWithoutUserInput
  questionVotes?: QuestionVoteCreateManyWithoutUserInput
  questionClicks?: QuestionClickCreateManyWithoutUserInput
  answerVotes?: AnswerVoteCreateManyWithoutUserInput
  answers?: AnswerCreateManyWithoutUserInput
}

export type ChatroomCreateWithoutMessagesInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  users?: UserCreateManyWithoutChatroomsInput
}

export type UserUpdateWithoutMessagesDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
  chatrooms?: ChatroomUpdateManyWithoutUsersInput
  questions?: QuestionUpdateManyWithoutUserInput
  questionVotes?: QuestionVoteUpdateManyWithoutUserInput
  questionClicks?: QuestionClickUpdateManyWithoutUserInput
  answerVotes?: AnswerVoteUpdateManyWithoutUserInput
  answers?: AnswerUpdateManyWithoutUserInput
}

export type UserUpsertWithoutMessagesInput = {
  update: UserUpdateWithoutMessagesDataInput
  create: UserCreateWithoutMessagesInput
}

export type ChatroomUpdateWithoutMessagesDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  users?: UserUpdateManyWithoutChatroomsInput
}

export type ChatroomUpsertWithoutMessagesInput = {
  update: ChatroomUpdateWithoutMessagesDataInput
  create: ChatroomCreateWithoutMessagesInput
}

export type ChatroomUpdateWithoutUsersDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  messages?: MessageUpdateManyWithoutChatroomInput
}

export type ChatroomUpdateManyDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
}

export type QuestionUpdateWithoutUserDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  votes?: QuestionVoteUpdateManyWithoutQuestionInput
  clicks?: QuestionClickUpdateManyWithoutQuestionInput
  answers?: AnswerUpdateManyWithoutQuestionInput
  categories?: CategoryUpdateManyWithoutQuestionsInput
}

export type QuestionUpdateManyDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type QuestionVoteUpdateWithoutUserDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
  question?: QuestionUpdateOneRequiredWithoutVotesInput
}

export type QuestionVoteUpdateManyDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
}

export type QuestionClickUpdateWithoutUserDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  question?: QuestionUpdateOneRequiredWithoutClicksInput
}

export type QuestionClickUpdateManyDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
}

export type AnswerVoteUpdateWithoutUserDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
  answer?: AnswerUpdateOneRequiredWithoutVotesInput
}

export type AnswerVoteUpdateManyDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
}

export type AnswerUpdateWithoutUserDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  votes?: AnswerVoteUpdateManyWithoutAnswerInput
  question?: QuestionUpdateOneRequiredWithoutAnswersInput
}

export type AnswerUpdateManyDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type MessageUpdateWithoutUserDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  chatroom?: ChatroomUpdateOneWithoutMessagesInput
}

export type MessageUpdateManyDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
}

export type QuestionUpdateWithoutCategoriesDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  votes?: QuestionVoteUpdateManyWithoutQuestionInput
  clicks?: QuestionClickUpdateManyWithoutQuestionInput
  answers?: AnswerUpdateManyWithoutQuestionInput
  user?: UserUpdateOneRequiredWithoutQuestionsInput
}

export type QuestionVoteUpdateWithoutQuestionDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
  user?: UserUpdateOneRequiredWithoutQuestionVotesInput
}

export type QuestionClickUpdateWithoutQuestionDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  user?: UserUpdateOneRequiredWithoutQuestionClicksInput
}

export type AnswerUpdateWithoutQuestionDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  deletedAt?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  votes?: AnswerVoteUpdateManyWithoutAnswerInput
  user?: UserUpdateOneRequiredWithoutAnswersInput
}

export type CategoryUpdateWithoutQuestionsDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
}

export type CategoryUpdateManyDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
}

export type AnswerVoteUpdateWithoutAnswerDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  upDown?: boolean | BoolFieldUpdateOperationsInput
  user?: UserUpdateOneRequiredWithoutAnswerVotesInput
}

export type MessageUpdateWithoutChatroomDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  user?: UserUpdateOneRequiredWithoutMessagesInput
}

export type UserUpdateWithoutChatroomsDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
  questions?: QuestionUpdateManyWithoutUserInput
  questionVotes?: QuestionVoteUpdateManyWithoutUserInput
  questionClicks?: QuestionClickUpdateManyWithoutUserInput
  answerVotes?: AnswerVoteUpdateManyWithoutUserInput
  answers?: AnswerUpdateManyWithoutUserInput
  messages?: MessageUpdateManyWithoutUserInput
}

export type UserUpdateManyDataInput = {
  id?: string | StringFieldUpdateOperationsInput
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  updatedAt?: Date | string | DateTimeFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  biography?: string | NullableStringFieldUpdateOperationsInput | null
  class?: string | NullableStringFieldUpdateOperationsInput | null
  major?: string | NullableStringFieldUpdateOperationsInput | null
  profileVisibility?: ProfileVisibility | EnumProfileVisibilityFieldUpdateOperationsInput
  linkedin?: string | NullableStringFieldUpdateOperationsInput | null
  facebook?: string | NullableStringFieldUpdateOperationsInput | null
  twitter?: string | NullableStringFieldUpdateOperationsInput | null
  instagram?: string | NullableStringFieldUpdateOperationsInput | null
  snapchat?: string | NullableStringFieldUpdateOperationsInput | null
  tiktok?: string | NullableStringFieldUpdateOperationsInput | null
  openToHelp?: boolean | NullableBoolFieldUpdateOperationsInput | null
  studentType?: StudentType | EnumStudentTypeFieldUpdateOperationsInput
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
