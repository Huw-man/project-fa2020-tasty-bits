"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const getSchema_1 = require("../cli/getSchema");
process.env.npm_config_user_agent = 'yarn/1.22.4 npm/? node/v12.18.3 darwin x64';
const FIXTURE_CWD = path_1.default.resolve(__dirname, 'fixtures', 'getSchema');
function testSchemaPath(fixtureName, schemaPathFromArgs) {
    return __awaiter(this, void 0, void 0, function* () {
        const cwd = path_1.default.resolve(FIXTURE_CWD, fixtureName);
        let syncResult;
        let asyncResult;
        try {
            syncResult = getSchema_1.getSchemaPathSyncInternal(schemaPathFromArgs, {
                cwd,
            });
        }
        catch (e) {
            syncResult = e;
        }
        try {
            asyncResult = yield getSchema_1.getSchemaPathInternal(schemaPathFromArgs, {
                cwd,
            });
        }
        catch (e) {
            asyncResult = e;
        }
        /**
         * Make paths relatives to enable snapshot testing on any machines
         */
        if (typeof syncResult === 'string') {
            syncResult = path_1.default.relative('.', syncResult);
        }
        if (typeof asyncResult === 'string') {
            asyncResult = path_1.default.relative('.', asyncResult);
        }
        if (syncResult instanceof Error) {
            syncResult.message = syncResult.message.replace(__dirname, '.');
        }
        if (asyncResult instanceof Error) {
            asyncResult.message = asyncResult.message.replace(__dirname, '.');
        }
        return {
            sync: syncResult,
            async: asyncResult,
        };
    });
}
it('returns null if no schema is found', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('no-schema');
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": null,
      "sync": null,
    }
  `);
}));
it('reads from --schema args first even if package.json is provided', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('pkg-json-with-schema-args', path_1.default.resolve(FIXTURE_CWD, 'pkg-json-with-schema-args', 'schema.prisma'));
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": "src/__tests__/fixtures/getSchema/pkg-json-with-schema-args/schema.prisma",
      "sync": "src/__tests__/fixtures/getSchema/pkg-json-with-schema-args/schema.prisma",
    }
  `);
}));
it('throws if schema args path is invalid', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('pkg-json-with-schema-args', path_1.default.resolve(FIXTURE_CWD, 'wrong_path'));
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": [Error: Provided --schema at ./fixtures/getSchema/wrong_path doesn't exist.],
      "sync": [Error: Provided --schema at ./fixtures/getSchema/wrong_path doesn't exist.],
    }
  `);
}));
it('reads relative schema path from the nearest package.json', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('pkg-json-valid-relative-path');
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": "src/__tests__/fixtures/getSchema/pkg-json-valid-relative-path/db/schema.prisma",
      "sync": "src/__tests__/fixtures/getSchema/pkg-json-valid-relative-path/db/schema.prisma",
    }
  `);
}));
it('reads schema path from the nearest package.json and throws if path does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('pkg-json-invalid-path');
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": [Error: Provided schema path at ./wrong-path from ./package.json doesn't exist.],
      "sync": [Error: Provided schema path at ./wrong-path from ./package.json doesn't exist.],
    }
  `);
}));
it('reads schema path from the nearest package.json and throws if path is not of type string', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('pkg-json-invalid-path-not-string');
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": [Error: Provided schema path configuration \`123\` at ./package.json must be of type string],
      "sync": [Error: Provided schema path configuration \`123\` at ./package.json must be of type string],
    }
  `);
}));
it('reads from the nearest package.json of the cwd', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('pkg-json-nearest/packages/a');
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": "src/__tests__/fixtures/getSchema/pkg-json-nearest/packages/a/db/schema.prisma",
      "sync": "src/__tests__/fixtures/getSchema/pkg-json-nearest/packages/a/db/schema.prisma",
    }
  `);
}));
it('finds the conventional prisma/schema path without configuration', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('conventional-path');
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": "src/__tests__/fixtures/getSchema/conventional-path/prisma/schema.prisma",
      "sync": "src/__tests__/fixtures/getSchema/conventional-path/prisma/schema.prisma",
    }
  `);
}));
it('finds the schema path in the root package.json of a yarn workspace from a child package', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('pkg-json-workspace-parent/packages/a');
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": "src/__tests__/fixtures/getSchema/pkg-json-workspace-parent/db/prisma.schema",
      "sync": "src/__tests__/fixtures/getSchema/pkg-json-workspace-parent/db/prisma.schema",
    }
  `);
}));
it('finds the conventional schema path with yarn workspaces', () => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield testSchemaPath('conventional-path-workspaces');
    expect(res).toMatchInlineSnapshot(`
    Object {
      "async": "src/__tests__/fixtures/getSchema/conventional-path-workspaces/packages/b/schema.prisma",
      "sync": "src/__tests__/fixtures/getSchema/conventional-path-workspaces/packages/b/schema.prisma",
    }
  `);
}));
//# sourceMappingURL=getSchema.test.js.map